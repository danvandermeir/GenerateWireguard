#!/bin/bash

#hostname or IP that peers ("clients") connect to, save yourself trouble and utilize a DNS name
#if blank attempts to determine WAN IP, if a WAN IP (or blank) and actual IP changes all peers ("clients") must be updated!
ENDPOINT=''
#port that peers ("clients") connect to, recommend changing from default (consult list of ports, Wiki?)
#if blank uses default port of 51820, ascends if used
PORT=''
#disconnect peers ("clients") and endpoint from LAN when true instead of false
#overriden by GATEWAY=true, if peer ("client") network conflict traffic is mostly routed to endpoint
ISOLATE=false
#peers ("clients") pass "all" traffic to endpoint's LAN route when true instead of false
#when true absolutely consider setting USE_DNS to true and selecting a "safe" DNS server for DNS_SRV!
GATEWAY=false

#######################################################
########## ADVANCED AND/OR OPTIONAL FEATURES ##########
#######################################################

#WireGuard interface this script controls
#if blank uses default of wg0 - wg255, ascends if used
#if blank and script doesn't contain interface name a new interface and script file will be generated (generatewg_$IFACE)
IFACE=''
#IP and network of the local Wireguard interface, CIDR format only: X.X.X.X/X
#if blank checks LAN for network, ascends networks if used
NTWRK=''
#peer ip range, CIDR format only: X.X.X.X/X
#if blank ascends from NTWRK, wraps, and ends at NTWRK_END or NTWRK
NTWRK_BEG=''
NTWRK_END=''
#attach VPN to this "LAN" interface name
#if blank uses system default network (network usually includes a NAT to the internet, routable only if GATEWAY=true)
LAN=''
#comma+space seperated list of CIDR LAN networks ('X.X.X.X/X, Y.Y.Y.Y/Y, Z.Z.Z.Z/Z') to attach VPN to
#peers ("clients") will route to and from these networks over endpoint in addition to NTWRK and LAN
ROUTES=''
#peers ("clients") will use DNS_SRV for DNS server(s) when true instead of false
USE_DNS=false
#if blank uses enpoint system's DNS server (USE_DNS must be true)
DNS_SRV=''
#base64 symmetric-key crypto is mixed with public key crypto for post-quantum resistance when true instead of false
#if false may lower CPU usage, perhaps a tiny boost in latency/speed as a result
USEPREKEY=true
#1-65535 seconds between empty encrypted packet sends by peers ("clients")
#if blank or 0 this is disabled
KEEPALIVE=300

NTWRK_MTU=''

PREUP=''

POSTUP=''

PREDOWN=''

POSTDOWN=''

########################################################################################
########## DO NOT EDIT BELOW SCRIPT UNLESS YOU KNOW WHAT YOU ARE DOING, KTHNX ##########
########################################################################################
err() {
	[ -n "$1" ] && printf -- "$1\n" 1>&2 && return 0
	return 1
}
errout() {
	err "$1"
	exit 1
}
#VERIFY EXISTANCE OF REQUIRED BINARIES/APPLICATIONS
BINARIES=('wg' 'ip')
for x in "${!BINARIES[@]}"; do
	BINARIES[$x]="$(command -v ${BINARIES[$x]})" || errout "Required binaries (applications) not available!"
done
#SET DEFAULTS FOR SCRIPT RUN
WRITEWGS=false
WGSUPDATE=false
WGCSTATUS='#'
WRITEWGC=false
ALLWGC=false
CHECKWGC=false
WRITEWGC=false
WGSFULLPATH="/etc/wireguard/$IFACE.conf"
WGSCRIPTNAME="${0##*/}"
WGSCRIPTPATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)/"
istorf() {
	[ $1 = true ] || [ $1 = false ] && return 0
	err "Not true or false ($1)!" && return 1
}
isnum() {
	[ -z "$1" ] || ! [[ $1 =~ ^[0-9]+$ ]] && err "Invalid numbers ($1)!" && return 1
	return 0
}
validlngth() {
	! [ -n "$1" ] || [ ${#1} -gt 63 ] && err "Invalid character length ($1)!" && return 1
	return 0
}
validchrs() {
	[ -z "$1" ] || ! [[ $1 =~ ^[A-Za-z0-9\.\-\_]+$ ]] && err "Invalid characters ($1)! Must be alphanumeric, period (.), minus (-), or underscore (_)!" && return 1
	return 0
}
validchrssyn() {
	! [ -n "$1" ] || ! validlngth "$1" || ! validchrs "$1" && return 1
	return 0
}
unusediface() {
	[ -z "$1" ] || ! validchrssyn "$1" && return 1
	[ -d "/sys/class/net/$1" ] && return 1
	return 0
}
unusedcfg() {
	[ -z "$1" ] || ! validchrssyn "$1" && return 1
	[ -f "/etc/wireguard/$1.conf" ] && return 1
	return 0
}
validdns() {
	[ -z "$1" ] && err "validdns function not provided a server to test!" && return 1
	dig +time=2 +tries=2 +retry=0 +short @"$1" A dns.opendns.com &> /dev/null || return 1
	return 0
}
isport() {
	[ -z "$1" ] || ! isnum "$1" || [ $1 -lt 1 ] || [ $1 -gt 65535 ] && err "Invalid port ($1)!" && return 1
	return 0
}
unusedport() {
	[ -z "$1" ] || ! isport "$1" && return 1
	/usr/bin/ss -lnp|/usr/bin/grep -q "$1" && err "Port in use ($1)!" && return 1
	return 0
}
isip() {
	[ -z "$1" ] || [[ ! $1 =~ ^[0-9/.]+$ ]] && err "Invalid IP address ($1)!" && return 1
	local a1 a2 a3 a4 v
	a4="$1"
	a1=${a4//.}
	[ $((${#a4} - ${#a1})) -ne 3 ] && err "Invalid IP address ($1)!" && return 1
	for y in {1..4}; do
		declare a$y="${a4%%.*}"
		v="a$y"
		[ -z "${!v}" ] || [ ${!v} -gt 255 ] && err "Invalid IP address ($1)!" && return 1
		a4="${a4#*.}"
	done
	return 0
}
ismultiip() {
	local x y
	x="$1"
	while [ -n "$x" ]; do
		y="${x%%, *}"
		! isip "$y" && return 1
		x="${x#$y, }"
	done
	return 0
}
isprivateip() {
	[ -z "$1" ] || ! isip "$1" && return 1
	#check if IP is in private ranges
	return 0
}
iscidr() {
	[ -z "$1" ] || [[ ! $1 =~ ^[0-9/./\/]+$ ]] || ! isip "${1%/*}" && err "Invalid CIDR address ($1)!" && return 1
	local m1
	m1="${1#*/}"
	[ -z "$m1" ] || ! isnum "$m1" || [ $m1 -lt 8 ] || [ $m1 -gt 32 ] && err "Invalid CIDR address ($1)!" && return 1
	return 0
}
ismulticidr() {
	local x y
	x="$1"
	while [ -n "$x" ]; do
		y="${x%%, *}"
		! iscidr "$y" && return 1
		x="${x#$y, }"
	done
	return 0
}
cidrtomask() {
	[ -z "$1" ] || [[ ! $1 =~ ^[0-9]+$ ]] || [ $1 -lt 8 ] || [ $1 -gt 32 ] && errout "CIDR bit length not provided to cidrtomask function (expected 8-32, got '$1')!"
	local i mask full part
	full=$(($1/8))
	part=$(($1%8))
	for ((i=0;i<4;i+=1)); do
		if [ $i -lt $full ]; then
			mask+=255
		elif [ $i -eq $full ]; then
			mask+=$((256 - 2**(8-$part)))
		else
			mask+=0
		fi
		test $i -lt 3 && mask+=.
	done
	printf "$mask"
	return 0
}
networkmin() {
	 [ -z $1 ] || ! iscidr "$1" && errout 'CIDR address not provided to networkmin function!'
	local a1 a2 a3 a4 m1 m2 m3 m4
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask ${1#*/})"
	a1=$((a1 & m1))
	a2=$((a2 & m2))
	a3=$((a3 & m3))
	a4=$((a4 & m4))
	printf "$a1.$a2.$a3.$a4"
	return 0
}
networkmax() {
	[ -z $1 ] || ! iscidr "$1" && errout 'CIDR address not provided to networkmax function!'
	local a1 a2 a3 a4 m1 m2 m3 m4
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask ${1#*/})"
	a1=$((( 255 ^ m1 ) | a1 ))
	a2=$((( 255 ^ m2 ) | a2 ))
	a3=$((( 255 ^ m3 ) | a3 ))
	a4=$((( 255 ^ m4 ) | a4 ))
	printf "$a1.$a2.$a3.$a4"
	return 0
}
getnextnetwork() {
	[ -z $1 ] || ! iscidr "$1" && errout "CIDR network not provided to getnextnetwork function!"
	local a1 a2 a3 a4 a5 a6 h1 h2 h3 h4 m1 m2 m3 m4 address
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	a5=${1#*/}
	a6=$((32 - a5))
	h1=$a1
	h2=$a2
	h3=$a3
	h4=$a4
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask $a5)"
	address=$((((((((((a1 << 8) | a2) << 8) | a3) << 8) | a4) >> a6) + 1) << a6 ))
	a4=$(( ((255 & address) & m4) | (h4 & (255 ^ m4)) ))
	address=$((address >> 8))
	a3=$(( ((255 & address) & m3) | (h3 & (255 ^ m3)) ))
	address=$((address >> 8))
	a2=$(( ((255 & address) & m2) | (h2 & (255 ^ m2)) ))
	address=$((address >> 8))
	a1=$(( ((255 & address) & m1) | (h1 & (255 ^ m1)) ))
	[ $h1 -eq 10 ] && [ $a1 -ne 10 ] && a1=10
	[ "$h1$h2" = "192168" ] && [ "$a1$a2" != "192168" ] && a1=192 && a2=168
	[ "$h1$h2" = "169254" ] && [ "$a1$a2" != "169254" ] && a1=169 && a2=254
	[ $a1 -eq 172 ] && [ $a2 -gt 31 ] && a2=16
	printf "$a1.$a2.$a3.$a4/$a5"
	return 0
}
getpriorhost() {
	[ -z $1 ] || ! iscidr "$1" && errout "CIDR address not provided to getpriorhost function!"
	local a1 a2 a3 a4 a5 m1 m2 m3 m4 i1 i2 i3 i4 address
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	a5="${1#*/}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask $a5)"
	i1=$((255 ^ m1))
	i2=$((255 ^ m2))
	i3=$((255 ^ m3))
	i4=$((255 ^ m4))
	address=$((((((((a1 << 8) | a2) << 8) | a3) << 8) | a4) - 1))
	a4=$((((255 & address) & i4) | (a4 & m4)))
	address=$((address >> 8))
	a3=$((((255 & address) & i3) | (a3 & m3)))
	address=$((address >> 8))
	a2=$((((255 & address) & i2) | (a2 & m2)))
	a1=$((((address >> 8) & i1) | (a1 & m1)))
	address="$a1.$a2.$a3.$a4"
	[ "$address" = '0.0.0.0' ] || [ "$address" = '255.255.255.255' ] || [ "$address" = "$(networkmin $address/$a5)" ] || [ "$address" = "$(networkmax $address/$a5)" ] && address="$(getpriorhost $address/$a5)"
	printf "$address"
	return 0
}
getnexthost() {
	[ -z $1 ] || ! iscidr "$1" && errout "CIDR address not provided to getnexthost function!"
	local a1 a2 a3 a4 a5 m1 m2 m3 m4 i1 i2 i3 i4 address
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	a5="${1#*/}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask $a5)"
	i1=$((255 ^ m1))
	i2=$((255 ^ m2))
	i3=$((255 ^ m3))
	i4=$((255 ^ m4))
	address=$((((((((a1 << 8) | a2) << 8) | a3) << 8) | a4) + 1))
	a4=$((((255 & address) & i4) | (a4 & m4)))
	address=$((address >> 8))
	a3=$((((255 & address) & i3) | (a3 & m3)))
	address=$((address >> 8))
	a2=$((((255 & address) & i2) | (a2 & m2)))
	a1=$((((address >> 8) & i1) | (a1 & m1)))
	address="$a1.$a2.$a3.$a4"
	[ "$address" = '0.0.0.0' ] || [ "$address" = '255.255.255.255' ] || [ "$address" = "$(networkmin $address/$a5)" ] || [ "$address" = "$(networkmax $address/$a5)" ] && address="$(getnexthost $address/$a5)"
	printf "$address"
	return 0
}
#################                                               NEEDS FIX!!!
rangeunused() {
	[ -z "$1" ] || ! iscidr "$1" && err "CIDR network not provided to rangeunused function ($1)!" && return 1
	local a1 a2 a3 a4 a5 cur max address
	address="$(networkmin $1)"
	#nmap check && return 1
	#icmp check && return 1
	IFS=. read -r a1 a2 a3 a4<<<"$(networkmax $1)"
	max=$(( ( a1 << 24 ) + ( a2 << 16 ) + ( a3 << 8 ) + a4 ))
	IFS=. read -r a1 a2 a3 a4<<<"$address"
	a5=${1#*/}
	while [[ "$(ip route get $a1.$a2.$a3.$a4/$a5)" == *"via"* ]] || return 1; do
		cur=$(( ( a1 << 24 ) + ( a2 << 16 ) + ( a3 << 8 ) + a4 ))
		[ $cur -eq $max ] && break
		a4=$(( a4 + 1 ))
		[ $a4 -eq 256 ] && a4=0 && a3=$(( a3 + 1 ))
		[ $a3 -eq 256 ] && a3=0 && a2=$(( a2 + 1 ))
		[ $a2 -eq 256 ] && a2=0 && a1=$(( a1 + 1 ))
		[ $a1 -eq 256 ] && a1=0
	done
	return 0
}
inntwrk() {
	[ -z "$1" ] || ! isip "$1" && return 1
	[ -z "$2" ] || ! iscidr "$2" && return 1
	[ "$(networkmin $1/${2#*/})" != "$(networkmin $2)" ] && return 1
	return 0
}
inrange() {
	[ -z "$1" ] && return 1
	[ -z "$2" ] || ! inntwrk "$2" "$1" && return 1
	[ -z "$3" ] || ! inntwrk "$3" "$1" && return 1
	[ "$2" = "$3" ] && err "Range begin and end are identical ($2)!" && return 1
	local x y z
	x="${1%/*}"
	y="${1#*/}"
	z="$2"
	while [ -n "$z" ]; do
		[ "$x" = "$z" ] && err "Range ($2 - $3) contains IP ($x)!" && return 1
		[ "$3" = "$z" ] && z='' || z="$(getnexthost $z/$y)"
	done
	return 0
}
getcidrof() {
	local address
	address=$(ip address show "$1" 2>/dev/null|grep 'inet ')
	address=${address#*inet }
	address=${address%% *}
	[ -z "$1" ] || [ -z "$address" ] || ! iscidr "$address" && err "getcidrof function provided invalid interface name ($1)!" && return 1
	printf "$(networkmin $address)/${address#*/}"
	return 0
}
getdefaultiface() {
	local x
	x=$(ip route show default)
	x=${x#* dev }
	x=${x%% *}
	[ -z "$x" ] && errout 'getdefaultiface function could not determine default interface!'
	printf "$x"
	return 0
}
generatenetworkfrom() {
	local address nextaddress
	if [ -n "$1" ]; then
		err "Attempting to generate a network from $1 interface!"
		address=$(getcidrof "$1")
	fi
	if [ -z $address ]; then
		address=$(getdefaultiface)
		err "Attempting to generate a network from default $address interface!"
		address=$(getcidrof "$address")
	fi
	! iscidr "$address" && errout 'generatenetworkfrom function could find network to generate from!'
	nextaddress=$(getnextnetwork "$address")
	while ! rangeunused "$nextaddress"; do
		nextaddress=$(getnextnetwork "$nextaddress")
		[ "$address" = "$nextaddress" ] && errout "generatenetworkfrom function could not determine an unused network!"
	done
	printf "$nextaddress"
	return 0
}
#################                                               NEEDS FIX!!!
clientconfignetwork() {
	#WARNING!!!! This function has the potential to "guess" prior existing networks based on peer configurations wrong!
		err "Attempting to determine $IFACE network from peers in configuration file!"
	local a1 a2 a3 a4 a5 a6 check lowest highest address generated
	if [ -n "$WGS" ]; then
		while IFS= read -r x || [ -n "$x" ]; do
			if [[ "$x" == "AllowedIPs = "* ]]; then
				address=${x//[!0-9\,\/\.]}
				address=${address%%,*}
				address=${address%/*}
				IFS=. read -r a1 a2 a3 a4<<<"$address"
			check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
				if [ -z $lowest ]; then
					lowest=$check
					highest=$check
				elif [ $check -lt $lowest ]; then
					lowest=$check
				elif [ $check -gt $highest ]; then
					highest=$check
				fi
			fi
		done <<< "$WGS"
		[ -z $lowest ] && errout 'clientconfignetwork function could not determine any peer configurations!'
	else
		errout 'No Wiregaurd server configuration for clientconfignetwork function!'
	fi
	printf 'clientconfignetwork function attempting to match an existing network to Wireguard configuration file peers!\n' 1>&2
	a6=$(generatenetworkfrom $1)
	generated=$(getnexthost $a6)
	IFS=. read -r a1 a2 a3 a4<<<"${generated%/*}"
	check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
	if [ $check -eq $lowest ] || [ $check -eq $((lowest - 1)) ]; then
		printf 'clientconfignetwork function matched a network for Wireguard configuration file peers! Verify network in configuration file!\n' 1>&2
		printf "$a6"
	else
		printf 'clientconfignetwork function attempting to guess network for Wireguard configuration file peers!\n' 1>&2
		for x in {30..8}; do
			IFS=. read -r a1 a2 a3 a4<<<"$(networkmin $address/$x)"
			a5="$a1.$a2.$a3.$((a4 + 1))"
			check=$((((a1 << 24) + (a2 << 16) + (a3 << 8) + a4) + 2))
			if [ $check -eq $lowest ]; then
				IFS=. read -r a1 a2 a3 a4<<<"$(networkmax $address/$x)"
				check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
				[ $check -gt $highest ] && address="$a5/$x" && a5=$x && break
			else
				IFS=. read -r a1 a2 a3 a4<<<"$(networkmax $address/$x)"
				generated="$a1.$a2.$a3.$((a4 - 1))"
				check=$((((a1 << 24) + (a2 << 16) + (a3 << 8) + a4) - 2))
				if [ $check -eq $highest ]; then
					IFS=. read -r a1 a2 a3 a4<<<"$a5"
					check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
					[ $check -le $lowest ] && address="$generated/$x" && a5=$x && break
				fi
			fi
			a5=''
		done
		if [ -z $a5 ]; then
			printf 'clientconfignetwork function could not determine a network from Wireguard confifuration file!\n' 1>&2
			return 1
		else
			if [ ${a6#*/} -lt $((a5 + 5)) ] && [ ${a6#*/} -gt $((a5 - 5)) ]; then
				printf 'clientconfignetwork function guessed a network close to existing network! Using existing network! Verify network in configuration file!\n' 1>&2
				printf "$a6"
			else
				printf 'clientconfignetwork function guessed a network! Verify network in configuration file!\n' 1>&2
				printf "$address"
			fi
		fi
	fi
}
GETARGS() {
	#present function call with getopts like interface
	local FLGVARNAME ARGVARNAME CURARG
	FLGVARNAME="FLG$$"
	ARGVARNAME="ARG$$"
	if [ -n "${!FLGVARNAME}" ]; then
		eval "${!FLGVARNAME}"
		eval "${!ARGVARNAME}"
	fi
	if declare -p FLG&>/dev/null; then
		if [ "${#FLG[@]}" -eq 0 ]; then
			unset $FLGVARNAME $ARGVARNAME $2 OPTARG
			return 1
		else
			for CURARG in "${!FLG[@]}"; do
				if [ $CURARG -eq 0 ]; then
					eval export "$2"="${FLG[0]}"
				else
					FLG[$((CURARG - 1))]="${FLG[$CURARG]}"
				fi
				unset FLG[$CURARG]
			done
			if [ ${#ARG[@]} -eq 0 ]; then
				unset OPTARG
			else
				[ -z "${ARG[0]}" ] && unset OPTARG
				for CURARG in "${!ARG[@]}"; do
					if [ $CURARG -eq 0 ]; then
						[ -n "${ARG[0]}" ] && export OPTARG="${ARG[0]}"
					else
						ARG[$((CURARG - 1))]="${ARG[$CURARG]}"
					fi
					unset ARG[$CURARG]
				done
			fi
			CURARG='$(declare -p FLG)'
			eval $FLGVARNAME="$CURARG"
			CURARG='$(declare -p ARG)'
			eval $ARGVARNAME="$CURARG"
			return 0
		fi
	fi
	local ALLFLGS SHRTFLGS TMPSHRTFLGS TMPLNGFLGS CURFLG TMP1 TMP2 REQARGS NOREQARGS ERRHNDL
	#input sanitize, build lists of accepted flags, then build array based on presented arguements and accepted flags
	ALLFLGS="$1"
	while [[ "$ALLFLGS" == *'::'* ]]; do
		ALLFLGS="${ALLFLGS/::/:}"
	done
	while [[ "$ALLFLGS" == *',,'* ]]; do
		ALLFLGS="${ALLFLGS/,,/,}"
	done
	while [[ "$ALLFLGS" == *'---'* ]]; do
		ALLFLGS="${ALLFLGS/---/--}"
	done
	TMPLNGFLGS="--${ALLFLGS#*--}"
	SHRTFLGS="${ALLFLGS%%--*}"
	SHRTFLGS="${SHRTFLGS//-/}"
	TMPSHRTFLGS="$SHRTFLGS"
	if [ "${SHRTFLGS::1}" = ':' ]; then
		SHRTFLGS="${SHRTFLGS:1}"
		ERRHNDL=true
	else
		ERRHNDL=false
	fi
	CURFLG=0
	REQARGS=''
	NOREQARGS=''
	for CURARG in "${@:3}"; do
		if [ "$CURARG" = '-' ] || [ "$CURARG" = '--' ]; then
			if $ERRHNDL; then
				local FLG[$CURFLG] ARG[$CURFLG]
				FLG[$CURFLG]='?'
				ARG[$CURFLG]="$CURARG"
				CURFLG=$((CURFLG + 1))
				continue 1
			else
				printf -- "$CURARG is invalid!\n" >&2
				return 1
			fi
		fi
		if [[ "$CURARG" == '-'* ]]; then
				if [ -n "$REQARGS" ]; then
					if $ERRHNDL; then
						while [ -n "$REQARGS" ]; do
							TMP1="${REQARGS%%,*}"
							local ARG[$TMP1]
							ARG[$TMP1]="${FLG[$TMP1]}"
							FLG[$TMP1]='?'
							REQARGS="${REQARGS#$TMP1,}"
						done
					else
						TMP1="${REQARGS%%,*}"
						printf -- "${FLG[$TMP1]} no supplied arguement!\n" >&2
						return 1
					fi
				fi
			if [[ "$CURARG" == '--'* ]]; then
				if [[ "$ALLFLGS" != *"$CURARG"* ]]; then
					if $ERRHNDL; then
						local FLG[$CURFLG] ARG[$CURFLG]
						FLG[$CURFLG]="?"
						ARG[$CURFLG]="$CURARG"
						CURFLG=$((CURFLG + 1))
						continue 1
					else
						printf -- "$CURARG is invalid flag!\n" >&2
						return 1
					fi
				fi
				if [[ "$TMPLNGFLGS" = *"$CURARG"* ]]; then
					TMP2="$TMPLNGFLGS"
					while [ -n "$TMP2" ]; do
						if [[ "$TMP2" = "$CURARG"* ]]; then
							local FLG[$CURFLG]
							FLG[$CURFLG]="$CURARG"
							TMP2="${TMP2#$CURARG}"
							if [ "${TMP2::1}" = ':' ]; then
								[ "${TMP2:1:1}" != ',' ] && TMPLNGFLGS="${TMPLNGFLGS/$CURARG:}"
								REQARGS="$REQARGS$CURFLG,"
							elif [ "${TMP2::1}" = ',' ]; then
								if [ "${TMP2:1:1}" = ':' ]; then
									REQARGS="$REQARGS$CURFLG,"
								else
									NOREQARGS="$NOREQARGS$CURFLG,"
								fi
							else
								TMPLNGFLGS="${TMPLNGFLGS/$CURARG:}"
								NOREQARGS="$NOREQARGS$CURFLG,"
							fi
							CURFLG=$((CURFLG + 1))
							break 1
						else
							TMP2="${TMP2:2}"
							TMP2="--${TMP2#*--}"
						fi
					done
				elif $ERRHNDL; then
					local FLG[$CURFLG] ARG[$CURFLG]
					FLG[$CURFLG]="?"
					ARG[$CURFLG]="$CURARG"
					CURFLG=$((CURFLG + 1))
					continue 1
				else
					printf -- "$CURARG cannot be used again!\n" >&2
					return 1
				fi
			else
				CURARG="${CURARG:1}"
				while [ -n "$CURARG" ]; do
					TMP1="${CURARG::1}"
					CURARG="${CURARG:1}"
					if [[ "$SHRTFLGS" != *"$TMP1"* ]]; then
						if $ERRHNDL; then
							local FLG[$CURFLG] ARG[$CURFLG]
							FLG[$CURFLG]="?"
							ARG[$CURFLG]="-$TMP1"
							CURFLG=$((CURFLG + 1))
							continue 1
						else
							printf -- "-$TMP1 is invalid flag!\n" >&2
							return 1
						fi
					fi
					if [[ "$TMPSHRTFLGS" = *"$TMP1"* ]]; then
						TMP2="$TMPSHRTFLGS"
						while [ -n "$TMP2" ]; do
							if [[ "$TMP2" = "$TMP1"* ]]; then
								local FLG[$CURFLG]
								FLG[$CURFLG]="$TMP1"
								TMP2="${TMP2:1}"
								TMP1="${TMP2::1}"
								if [ "$TMP1" = ':' ]; then
									[ "${TMP2:1:1}" != ',' ] && TMPSHRTFLGS="${TMPSHRTFLGS/${FLG[$CURFLG]}:}"
									REQARGS="$REQARGS$CURFLG,"
								elif [ "$TMP1" = ',' ]; then
									if [ "${TMP2:1:1}" = ':' ]; then
										REQARGS="$REQARGS$CURFLG,"
									else
										NOREQARGS="$NOREQARGS$CURFLG,"
									fi
								else
									TMPSHRTFLGS="${TMPSHRTFLGS/${FLG[$CURFLG]}}"
									NOREQARGS="$NOREQARGS$CURFLG,"
								fi
								FLG[$CURFLG]="-${FLG[$CURFLG]}"
								CURFLG=$((CURFLG + 1))
								break 1
							else
								TMP2="${TMP2:1}"
							fi
						done
					elif $ERRHNDL; then
						local FLG[$CURFLG] ARG[$CURFLG]
						FLG[$CURFLG]="?"
						ARG[$CURFLG]="-$TMP1"
						NOREQARGS="$NOREQARGS$CURFLG,"
						CURFLG=$((CURFLG + 1))
						continue 1
					else
						printf -- "-$TMP1 cannot be used again!\n" >&2
						return 1
					fi
				done
			fi
		elif [ -n "$REQARGS" ]; then
			TMP1="${REQARGS%%,*}"
			local ARG[$TMP1]
			ARG[$TMP1]="$CURARG"
			REQARGS="${REQARGS#$TMP1,}"
			NOREQARGS="$NOREQARGS$TMP1,"
		elif [ -z "${FLG[0]}" ]; then
			if $ERRHNDL; then
				local FLG[$CURFLG] ARG[$CURFLG]
				FLG[$CURFLG]="?"
				ARG[$CURFLG]="$CURARG"
				CURFLG=$((CURFLG + 1))
			else
				printf -- "$CURARG is not a flag!\n" >&2
				return 1
			fi
		elif [ -z "$REQARGS" ]; then
			if $ERRHNDL; then
				local FLG[$CURFLG] ARG[$CURFLG]
				FLG[$CURFLG]='?'
				if [[ "$NOREQARGS" = *"$((CURFLG - 1))"* ]]; then
					ARG[$CURFLG]="$CURARG"
					NOREQARGS="$NOREQARGS$CURFLG,"
				elif [ "${FLG[$((CURFLG - 1))]}" = '?' ]; then
					ARG[$CURFLG]="${ARG[$((CURFLG - 1))]}"
				else
					ARG[$CURFLG]="${FLG[$((CURFLG - 1))]}"
				fi
				CURFLG=$((CURFLG + 1))
			else
				printf -- "${FLG[$((CURFLG - 1))]} over supplied arrguements!\n" >&2
				return 1
			fi
		fi
	done
	if [ -n "$REQARGS" ]; then
		if $ERRHNDL; then
			while [ -n "$REQARGS" ]; do
				TMP1="${REQARGS%%,*}"
				local ARG[$TMP1]
				ARG[$TMP1]="${FLG[$TMP1]}"
				FLG[$TMP1]='?'
				REQARGS="${REQARGS#$TMP1,}"
			done
		else
			TMP1="${REQARGS%%,*}"
			printf -- "${FLG[$TMP1]} no supplied arguement!\n" >&2
			return 1
		fi
	fi
	#first output to function call location
	if [ -n "${FLG[0]}" ]; then
		for REQARGS in "${!FLG[@]}"; do
			if [ $REQARGS -eq 0 ]; then
				eval export "$2"="${FLG[0]}"
			else
				FLG[$((REQARGS - 1))]="${FLG[$REQARGS]}"
			fi
			unset FLG[$REQARGS]
		done
		if [ ${#ARG[@]} -ne 0 ]; then
			[ -z "${ARG[0]}" ] && unset OPTARG
			for REQARGS in "${!ARG[@]}"; do
				if [ $REQARGS -eq 0 ]; then
					[ -n "${ARG[0]}" ] && export OPTARG="${ARG[0]}"
				else
					ARG[$((REQARGS - 1))]="${ARG[$REQARGS]}"
				fi
				unset ARG[$REQARGS]
			done
		fi
		REQARGS='$(declare -p FLG)'
		eval export $FLGVARNAME="$REQARGS"
		REQARGS='$(declare -p ARG)'
		eval export $ARGVARNAME="$REQARGS"
		return 0
	else
		return 1
	fi
}
WGSCRIPTWRITE() {
	local x WGSCRIPTPATH_NEW WGSCRIPT_NEW
	WGSCRIPTPATH_NEW="/etc/wireguard/generatewg_$1"
	if [ ! -f "$WGSCRIPTPATH_NEW" ]; then
		WGSCRIPT_NEW=($(<$WGSCRIPTPATH$WGSCRIPTNAME))
		for x in "${!WGSCRIPT_NEW[@]}"; do
			[[ "${}" = "IFACE=''"* ]] && WGSCRIPT_NEW[$x]="IFACE='$1'" && break 1
		done
		printf -- "${WGSCRIPT_NEW[@]}" > "$WGSCRIPTPATH_NEW"
		chown root "$WGSCRIPTPATH_NEW"
		chmod 700 "$WGSCRIPTPATH_NEW"
		err "Script copied for use with $1!"
	fi
	err "Use $WGSCRIPTPATH_NEW instead! Script file can be moved."
}
HALP='

Quick start:
1) Run (optional, but recommend non-standard port: " --port <PORT>"):
	'"$WGSCRIPTPATH$WGSCRIPTNAME"' --endpoint <FQDN> --port <PORT> -LGpp <CLIENTNAME1> <CLIENTNAME2>
2) Securely give client file to client for import or use with wg-quick.


Wireguard was built with peer to peer relationships.
This tool is used to generate a server and client style relationship for Wireguard interfaces.
Effectively, this is a server and client manager.
When script is called server and client configuration files in wg-quick format will be generated.
Endpoint will be configured for clients to connect as requested.
Edit options in either the CLI as described below, or by editing script variables.

Old server configuration file will be copied to /etc/wireguard/<INTERFACE>.conf.old
Old client configuration files will be replaced, but should not remain on disk after secure transmission to clients!
All names must be alphanumeric, period (.), minus (-), or underscore (_) with a maximum of 63 characters.

Options:
	-L			make changes live
	-i			use this endpoint Wireguard interface name
					determination order: -i <NAME>, script variable (IFACE), script name (generatewg_<IFACE>)
					if ommited generate unused wg0-wg255 interface name
	--iface			change endpoint Wireguard interface name
	-p			list client(s) setup and status if no other operations requested, one client name per iteration
	-P			list all clients setups and status if no other operations requested
	-G			generate new configuration for client(s)
					client specific settings are preserved (disabled status, gateway, network, isolation, routes, DNS, and MTU)
	-D			disable client(s)
	-E			enable client(s)
	-R			remove client(s)


All clients will have required configurations regenerated:
	--endpoint		endpoint hostname/IP clients connect to
					if hostname ommited at inception script will attempt to find WAN IP
					if IP is used and IP changes clients will require configuration file update (script run with -PGL options)
	--port			endpoint port clients connect to
					if ommited at inception uses first unused port from 51820 and ascends
	--gateway-on, --gateway-off
				route or do not route "all" client traffic through endpoint
					if ommited at inception this is off


Clients may need to have required configurations regenerated:
	--network		CIDR address and network for endpoint Wireguard interface (192.168.0.1/24)
					applied to specific clients via -P or -p options
					if ommited at inception a suitable network will be generated from --lan network
	--ip-beg, --ip-end
				client IP range begining and ending
					if ommited at inception starts ascending from --network address and ends at --network address, loops
	--lan			the endpoint system interface that client traffic will be routed to if enabled by isolation settings
					if ommited at inception this will be the system defafult gateway interface
	--unisolate, --isolate
				do or do not route --lan network traffic to/from clients through endpoint
					applied to specific client(s) via -P or -p options, otherwise acts as server default
					if ommited at inception this is unisolated
	--route-add, --route-rem
				add or remove CIDR address (192.168.0.1/32) or network (192.168.0.0/24) to be routed, one per iteration
					applied to specific client(s) via -P or -p options, otherwise acts as server default
					when made live if --lan interface is unisolated specified client(s) or server will be granted access
	--dns			DNS server address
					applied to specific clients via -P or -p options, otherwise acts as server default
					if ommited at inception this is empty
	--dns-on, --dns-off
				do or do not force clients to use DNS server
					applied to specific client(s) via -P or -p options, otherwise acts as server default
					if ommited at inception this is off
	--mtu			Maximum Transmission Unit size (68 - 64000)
					applied to specific client(s) via -P or -p options, otherwise acts as server default
					if ommited this allows wg-quick to configure the MTU
	--keep			Keep alive packet transmission time in seconds (15 - 65535)
					applied to specific client(s) via -P or -p options, otherwise acts as server default
					if ommited this allows wg-quick to configure the MTU'
[ -z "$@" ] && errout "$HALP"
while GETARGS :L,i:p:,P,G,D,E,--endpoint:--port:--iface:--network:--ip-beg:--ip-end:--lan:--isolate,--unisolate,--route-add:,--route-rem:,--gateway-on,--gateway-off,--dns-on,--dns-off,--dns:--mtu:--keepalive: x "$@"; do
	case $x in
		-L)
			WGSUPDATE=true;;
		-i)
			validchrssyn "$OPTARG" || errout 'Invalid -i arguement!'
			if unusedcfg "$OPTARG"; then
				err "No configuration file! Creating new Wireguard interface ($OPTARG)!"
				unusediface "$OPTARG" || errout 'Interface exists!'
				WGSCRIPT=true
				WRITEWGS=true
				WRITEWGC=true
			fi
			IFACE="$OPTARG";;
		-p)
			validchrssyn "$OPTARG" || errout 'Invalid -p arguement!'
			[ -n "$WGC" ] && WGC+=", $OPTARG" || WGC="$OPTARG";;
		-P)
			ALLWGC=true;;
		-G)
			WRITEWGS=true
			WRITEWGC=true;;
		-D)
			WRITEWGS=true
			DISABLE=true;;
		-E)
			WRITEWGS=true
			ENABLE=true;;
		--endpoint)
			ENDPOINT="$OPTARG"
			WGSCRIPT=true
			WRITEWGS=true
			WRITEWGC=true;;
		--port)
			unusedport "$OPTARG" || errout 'Invalid --port arguement!'
			PORT="$OPTARG"
			WGSCRIPT=true
			WRITEWGS=true
			WRITEWGC=true;;
		--iface)
			validchrssyn "$OPTARG" || errout 'Invalid --iface arguement!'
			unusediface "$OPTARG" || errout 'Invalid --iface arguement! Interface exists!'
			unusedcfg "$OPTARG" && errout 'Invalid --iface arguement! Configuration file exists!'
			NEW_IFACE="$OPTARG"
			WGSCRIPT=true
			WRITEWGS=true;;
		--network)
			iscidr "$OPTARG" || errout 'Invalid --network arguement!'
			rangeunused "$OPTARG" || errout 'Invalid --network arguement! Network in use!'
			NTWRK="$OPTARG"
			WGSCRIPT=true
			WRITEWGS=true
			WRITEWGC=true;;
		--ip-beg)
			isip "$OPTARG" || errout 'Invalid --ip-beg arguement!'
			NTWRK_BEG="$OPTARG"
			WGSCRIPT=true
			WRITEWGS=true
			CHECKWGC=true;;
		--ip-end)
			isip "$OPTARG" || errout 'Invalid --ip-end arguement!'
			NTWRK_END="$OPTARG"
			WGSCRIPT=true
			WRITEWGS=true
			CHECKWGC=true;;
		--isolate)
			ISOLATE=false
			WGSCRIPT=true
			WRITEWGS=true
			WRITEWGC=true;;
		--unisolate)
			ISOLATE=true
			WGSCRIPT=true
			WRITEWGS=true
			WRITEWGC=true;;
		--gateway-on)
			WRITEWGC=true
			WGSCRIPT=true
			WRITEWGS=true
			GATEWAY=true;;
		--gateway-off)
			WRITEWGC=true
			WGSCRIPT=true
			WRITEWGS=true
			GATEWAY=false;;
		--lan)
			unusediface "$OPTARG" && errout 'Invalid --lan arguement! Interface does not exist!'
			LAN="$OPTARG"
			WGSCRIPT=true
			WRITEWGS=true
			WRITEWGC=true;;
		--network-add)
			CHECKWGC=true
			WGSCRIPT=true
			WRITEWGS=true
			iscidr "$OPTARG" || errout 'Invalid --network-add arguement!'
			[ -n "$ADD_ROUTES" ] && ADD_ROUTES+=", $OPTARG" ||  ADD_ROUTES="$OPTARG";;
		--network-rem)
			CHECKWGC=true
			WGSCRIPT=true
			WRITEWGS=true
			iscidr "$OPTARG" || errout 'Invalid --network-rem arguement!'
			[ -n "$REM_ROUTES" ] && REM_ROUTES+=", $OPTARG" ||  REM_ROUTES="$OPTARG";;
		--dns-on)
			WRITEWGC=true
			WGSCRIPT=true
			WRITEWGS=true
			USE_DNS=true;;
		--dns-off)
			WRITEWGC=true
			WGSCRIPT=true
			WRITEWGS=true
			USE_DNS=false;;
		--dns)
			validdns "$OPTARG" || errout 'Invalid --nds arguement!'
			WRITEWGC=true
			WGSCRIPT=true
			CHECKWGS=true
			DNS_SRV="$OPTARG";;
		--mtu)
			isnum "$OPTARG" || [ $OPTARG -lt 68 ] || [ $OPTARG -gt 64000 ] && errout "Invalid --mtu arguement!\nMust be 0 (automatically determined by wg-quick) or 68 to 64000!"
			[ $OPTARG -gt 1500 ] && err 'MTU should be 1500 max for internet traffic!'
			CHECKWGC=true
			WGSCRIPT=true
			WRITEWGS=true
			NTWRK_MTU="$OPTARG";;
		--keepalive)
			! isnum "$OPTARG" || [ $OPTARG -lt 15 ] || [ $OPTARG -gt 65535 ] && errout "Invalid --keep arguement! Must be 0 (disabled) or 15 to 65535!"
			CHECKWGC=true
			WGSCRIPT=true
			WRITEWGS=true
			NTWRK_KEEPALIVE="$OPTARG";;
		:)
			errout "Empty arguement to $OPTARG!$HALP";;
		?|*)
			errout "$HALP";;
	esac
done
#DETERMINE WIREGAURD INTERFACE NAME FROM SCRIPT NAME (wireguard_X), SCRIPT PATH, OR CREATES NEW DEFAULT WIREGAURD INTERFACE (wgX) WITH CONFIGURATION FILES
#VERIFY SCRIPT NAME
if [ -z $IFACE ]; then
	if [ ! "$WGSCRIPTNAME" = 'generatewg_' ] && [[ "$WGSCRIPTNAME" == 'generatewg_'* ]]; then
		IFACE="${WGSCRIPTNAME#*_}"
		validchrssyn "$IFACE" || errout "Script interface name IFACE variable not set and script name contains invalid Wireguard interface name!"
	else
		for x in {0..255}; do
			if unusediface "wg${x}" && unusedcfg "wg${x}"; then
				IFACE="wg$x"
				err "Creating new Wireguard interface ($IFACE)!"
				WGSCRIPT=true
				WRITEWGS=true
				WRITEWGC=true
				break 1
			fi
		done
		[ -z "$IFACE" ] && errout 'Could not generate an interface name! Interfaces wg0 - wg255 used!'
	fi
elif [ "$WGSCRIPTNAME" != "generatewg_$IFACE" ]; then
	WGSCRIPT=true
fi
#PARSE CONFIG FILE [Interface] SECTION
CUR_USEPREKEY=false
CUR_GATEWAY=false
CUR_ISOLATE=false
if [ -f "$WGSFULLPATH" ]; then
	WGCONFIG=($(<$WGSFULLPATH))
	for x in "${!WGCONFIG[@]}"; do
		case "${WGCONFIG[$x]}" in
			\#generatewg_version = *) CUR_VERSION="${WGCONFIG[$x]#\#generatewg_version = }"
				isnum "$CUR_VERSION" || errout "Invalid version number from configuration file!"
				[ "$VERSION" = '1' ] || errout "Configuration file ($WGSFULLPATH) is from newer script version ($CUR_VERSION)!\nCannot continue with script version $VERSION ($WGSCRIPTPATH$WGSCRIPTNAME)!";;
			PrivateKey = *) PRIKEY="${WGCONFIG[$x]#PrivateKey = }";;
			ListenPort = *) CUR_PORT="${WGCONFIG[$x]#ListenPort = }"
				isport "$CUR_PORT" || errout 'Invalid endpoint port from configuration file!';;
			\#PresharedKey) CUR_USEPREKEY=true;;
			\#lan = *) CUR_LAN="${WGCONFIG[$x]#\#lan = }"
				unusediface "$CUR_LAN" && errout "Invalid endpoint LAN interface from configuration file ($CUR_LAN)!";;
			\#gateway) CUR_GATEWAY=true;;
			\#isolate) CUR_ISOLATE=true;;
			\#routes = *) CUR_ROUTES="${WGCONFIG[$x]#\#routes = }"
				ismulticidr "$CUR_ROUTES" || errout "Routes are incorrect from configuration file ($CUR_ROUTES)!";;
			\#beg = *) CUR_NTWRK_BEG="${WGCONFIG[$x]#\#beg = }"
				isip "$CUR_NTWRK_BEG" || errout 'Invalid client range begining from configuration file!';;
			\#end = *) CUR_NTWRK_END="${WGCONFIG[$x]#\#end = }"
				isip "$CUR_NTWRK_END" || errout 'Invalid client range ending from configuration file!';;
			\#Endpoint = *) CUR_ENDPOINT="${WGCONFIG[$x]#\#Endpoint = }";;
			PersistentKeepalive = *) CUR_NTWRK_KEEPALIVE="${WGCONFIG[$x]#PersistentKeepalive = }"
					! isnum "$CUR_NTWRK_KEEPALIVE" || [ $CUR_NTWRK_KEEPALIVE -lt 15 ] || [ $CUR_NTWRK_KEEPALIVE -gt 65535 ] && errout 'Invalid keepalive time in seconds from configuration file!';;
			Address = *) CUR_NTWRK="${WGCONFIG[$x]#Address = }"
				iscidr "$CUR_NTWRK" || errout "Invalid endpoint interface CIDR address from configuration file ($CUR_NTWRK)!"
				[ "$(networkmin $CUR_NTWRK)" = "${CUR_NTWRK#*/}" ] || [ "$(networkmax $CUR_NTWRK)" = "${CUR_NTWRK#*/}" ] && errout "Endpoint interface is network/broadcast (invalid address) from configuration file ($CUR_NTWRK)!";;
			\#DNS = *) CUR_DNS_SRV="${WGCONFIG[$x]}"
				validdns "$CUR_DNS_SRV" || errout 'Unreachable or invalid DNS server from configuration file!';;
			\#use_dns) CUR_USE_DNS=true;;
			MTU = *) CUR_NTWRK_MTU="${WGCONFIG[$x]#* = }"
				isnum "$CUR_NTWRK_MTU" || [ $OPTARG -lt 68 ] || [ $OPTARG -gt 64000 ] && errout "Invalid --mtu arguement!\nMust be 0 (automatically determined by wg-quick) or 68 to 64000!";;
\#PreUp = *) CUR_PREUP="${WGCONFIG[$x]#* = }";;
\#PostUp = *) CUR_POSTUP="${WGCONFIG[$x]#* = }";;
\#PreDown = *) CUR_PREDOWN="${WGCONFIG[$x]#* = }";;
\#PostDown = *) CUR_POSTDOWN="${WGCONFIG[$x]#* = }";;
			*\[Peer]*) unset WGCONFIG[$x] && break 1;;
		esac
		unset WGCONFIG[$x]
	do
else
	WRITEWGS=true
fi
#INPUT SANTIZATIONS
#VERIFY ENDPOINT PORT
if [ -n "$PORT" ]; then
	if [ -z "$CUR_PORT" ]; then
		isport "$PORT" || errout 'Invalid endpoint port from script!'
	elif [ $CUR_PORT -ne $PORT ]; then
		unusedport "$PORT" || errout 'Invalid endpoint port from script!'
		err "Changing endpoint port from $CUR_PORT to $PORT!\nAll clients will have configuration files generated!\nClients will require these configuration files once changes are live!"
		unset CUR_PORT
		WGSCRIPT=true
		WRITEWGS=true
		WRITEWGC=true
	fi
elif [ -n "$CUR_PORT" ]; then
	PORT=$CUR_PORT
	unset CUR_PORT
else
	PORT=51820
	while ! unusedport "$PORT"; do
		PORT=$((PORT + 1))
	done
	WGSCRIPT=true
	WRITEWGS=true
	WRITEWGC=true
fi
#VERIFY WIREGUARD SERVER LAN TO USE
if [ -n "$LAN" ]; then
	unusediface "$LAN" && errout 'Invalid endpoint LAN interface from script!'
	if [ -n "$CUR_LAN" ] && [ "$CUR_LAN" != "$LAN" ]; then
		err "Changing endpoint interface network from $CUR_LAN to $LAN!\nClients may need configuration files generated!\nClients will require these configuration files once changes are live!"
		unset CUR_NTWRK
		WGSCRIPT=true
		WRITEWGS=true
		CHECKWGC=true
	fi
elif [ -n "$CUR_LAN" ]; then
	LAN="$CUR_LAN"
	unset CUR_LAN
else
	LAN=$(getdefaultiface)
	WGSCRIPT=true
	WRITEWGS=true
	CHECKWGC=true
fi
LAN_ADDR="$(getcidrof $LAN)"
LAN_NTWRK="$(networkmin $LAN_ADDR)/${LAN_ADDR#*/}"
unset LAN_ADDR
#VERIFY WIREGAURD SERVER INTERFACE IP AND NETWORK
if [ -n "$NTWRK" ]; then
	! iscidr "$NTWRK" && errout "Invalid endpoint interface CIDR address from script or user ($NTWRK)!"
	[ "$(networkmin $NTWRK)" = "${NTWRK#*/}" ] || [ "$(networkmax $NTWRK)" = "${NTWRK#*/}" ] && errout "Endpoint interface from script or user is network/broadcast, not an address (got '$NTWRK', try '$(getnexthost $NTWRK)'?)!"
	! rangeunused "$NTWRK" && errout "$NTWRK is in use!"
	if [ -n "$CUR_NTWRK" ] && [ "$CUR_NTWRK" != "$NTWRK" ]; then
		err "Changing endpoint interface network from $CUR_NTWRK to $NTWRK!\nClients may need configuration files generated, and will require these configuration files once changes are live!"
		unset CUR_NTWRK
		WRITEWGS=true
		CHECKWGC=true
	fi
elif [ -n "$CUR_NTWRK" ]; then
	NTWRK="$CUR_NTWRK"
	unset CUR_NTWRK
else
	[ ${#WGCONFIG[@]} -ne 0 ] && NTWRK=$(clientconfignetwork "$IFACE")
	[ -z "$NTWRK" ] && NTWRK="$(generatenetworkfrom $LAN)" && NTWRK="$(getnexthost $NTWRK)/${NTWRK#*/}"
	err "Using $NTWRK for $IFACE interface!"
	WRITEWGS=true
	CHECKWGC=true
fi
NTWRK_SUB="${NTWRK#*/}"
NTWRK_NTWRK="$(networkmin $NTWRK)/$NTWRK_SUB"





#VERIFY IF PEERS SHOULD USE PRESHARED KEY
if [ -n "$USEPREKEY" ]; then
	! torf "$USEPREKEY" && errout "USEPREKEY variable not true or false from script!"
	if [ -n "$CUR_USEPREKEY" ] && [ $CUR_USEPREKEY != $USEPREKEY ]; then
		if $USEPREKEY; then
			err "The server now requires clients use a preshared key!\nAll existing clients not already using a key will have keys generated.\nClients must update their configuration once live!"
		else
			err "The server will not require clients use a preshared key!\nExisting clients will have no preshared key after next key generation unless specific clients have this requirement!"
		fi
		unset CUR_USEPREKEY
		WRITEWGS=true
		CHECKWGC=true
	fi
else
	USEPREKEY=$CUR_USEPREKEY
	unset CUR_USEPREKEY
fi
#VERIFY ADDITIONAL ROUTES TO FORWARD FOR ALL CLIENTS
if [ -n "$ROUTES" ]; then
	! ismulticidr "$ROUTES" && errout "$ROUTES routes are incorrect from script!"
	if [ -n "$CUR_ROUTES" ] && [ "$CUR_ROUTES" != "$ROUTES" ]; then
		err "Changing additional client routes from:\n$CUR_ROUTES\nto:\n$ROUTES\nClients with different routes will have configuration files generated, and will require these configuration files once changes are live!"
		unset CUR_ROUTES
		WRITEWGS=true
		CHECKWGC=true
	fi
elif [ -n "$CUR_ROUTES" ]; then
	NTWRK="$CUR_ROUTES"
	unset CUR_ROUTES
else
	ROUTES=''
fi
if [ -n "$ADD_ROUTES" ]; then
	err "Attempting addition to all client routes from:\n$ROUTES\nto:"
	while [ -n "$ADD_ROUTES" ]; do
		x="${ADD_ROUTES%%, *}"
		! iscidr "$x" || [ "$x" != "$(networkmin $x)/${x#*/}" ] && errout "$x route is not a CIDR network from user (Should be $(networkmin $x)/${x#*/}?)!"
		ADD_ROUTES="${ADD_ROUTES#*, }"
		if [ -n "$ROUTES" ]; then
			if [[ "$ROUTES" = *"$x"* ]]; then
				err "Route $x can not be added as it is already an existing route!"
			else
				ROUTES="$ROUTES, $x"
				WRITEWGS=true
				CHECKWGC=true
			fi
		else
			ROUTES="$x"
			WRITEWGS=true
			CHECKWGC=true
		fi
	done
	err "$ROUTES\nClients with different routes will have configuration files generated, and will require these configuration files once changes are live!"
fi
if [ -n "$REM_ROUTES" ]; then
	if [ -z "$ROUTES" ]; then
		errout "Can not remove routes as none exist ($REM_ROUTES)!"
	else
		err "Attempting removal of all client routes from:\n$ROUTES\nto:"
		while [ -n "$REM_ROUTES" ]; do
			x="${REM_ROUTES%%, *}"
			! iscidr "$x" || [ "$x" != "$(networkmin $x)/${x#*/}" ] && errout "$x route is not a CIDR network from user (Should be $(networkmin $x)/${x#*/}?)!"
			REM_ROUTES="${REM_ROUTES#*, }"
			if [[ "$ROUTES" = *"$x"* ]]; then
				ROUTES="${ROUTES//$x}"
				ROUTES="${ROUTES//, , /, }"
				[[ "$ROUTES" = ', '* ]] && ROUTES="${ROUTES#, *}"
				[[ "$ROUTES" = *', ' ]] && ROUTES="${ROUTES%*, }"
				WRITEWGS=true
				CHECKWGC=true
			else
				err "Route $x can not be removed as it is not currently routed!"
			fi
		done
		err "$ROUTES\nClients with different routes will have configuration files generated, and will require these configuration files once changes are live!"
	fi
fi
#VERIFY IF PEERS SHOULD FORWARD "ALL" TRAFFIC TO ENDPOINT
if [ -n "$GATEWAY" ]; then
	! torf "$GATEWAY" && errout "GATEWAY variable not true or false from script!"
	if [ $CUR_GATEWAY != $GATEWAY ]; then
		$GATEWAY && err 'Enabling endpoint to forward all traffic "internet gateway"!' || err 'Disabling endpoint to forward all traffic "internet gateway"!'
		err "All clients will have configuration files generated!\nAll clients must update to this new configuration once live!"
		unset CUR_GATEWAY
		WRITEWGS=true
		WRITEWGC=true
	fi
else
	GATEWAY=$CUR_GATEWAY
	unset CUR_GATEWAY
fi
#VERIFY IF PEERS SHOULD FORWARD ONLY VPN NETWORK
if [ -n "$ISOLATE" ]; then
	! torf "$ISOLATE" && errout "ISOLATE variable not true or false from script!"
	if [ $CUR_ISOLATE != $ISOLATE ]; then
		if ! $GATEWAY; then
			if $ISOLATE; then
				err "Isolating clients and $IFACE interface traffic to reach only $NTWRK_NTWRK network!"
			else
				err "Adding routing from endpoint interface $IFACE network $NTWRK_NTWRK to:\nLAN interface ($LAN) network: $LAN_NTWRK\nAdditional interface routes: $ROUTES\nAdditional client routes (check clients below)!"
			fi
			err "Clients may need configuration files generated, and will require these configuration files once changes are live!"
			CHECKWGC=true
		fi
		unset CUR_ISOLATE
		WRITEWGS=true
	fi
else
	ISOLATE=$CUR_ISOLATE
	unset ISOLATE
fi
				#VERIFY SPECIFIED PEER BEGINING AND END IP RANGE
				if [ -n "$NTWRK_BEG" ]; then
					if [ -z "$CUR_NTWRK_BEG" ]; then
						isip "$NTWRK_BEG" || errout "Invalid client range begin IP from script ($NTWRK_BEG)!"
					elif [ "$CUR_NTWRK_BEG" != "$NTWRK_BEG" ]; then
						err "Client range begin changing ($CUR_NTWRK_BEG to $NTWRK_BEG)!\nClients may need configuration files generated, and will require these configuration files once changes are live!"
						unset CUR_NTWRK_BEG
						WGSCRIPT=true
						WRITEWGS=true
						CHECKWGC=true
					fi
				elif [ -n "$CUR_NTWRK_BEG" ]; then
					NTWRK_BEG="$CUR_NTWRK_BEG"
					unset CUR_NTWRK_BEG
				else
					NTWRK_BEG=$(getnexthost "$NTWRK")
					WGSCRIPT=true
					WRITEWGS=true
					CHECKWGC=true
				fi
				[ -n "$CUR_NTWRK_END" ] && ! inrange "$NTWRK" "$NTWRK_BEG" "$CUR_NTWRK_END" && errout 'Invalid peer (client) range from configuration file!'
				if [ -n "$NTWRK_END" ]; then
					if [ -z "$CUR_NTWRK_END" ]; then
						inrange "$NTWRK" "$NTWRK_BEG" "$NTWRK_END" && errout 'Invalid client range from script!'
					elif [ "$CUR_NTWRK_END" != "$NTWRK_END" ]; then
						err "Client range end changing ($CUR_NTWRK_END to $NTWRK_END)!\nClients may need configuration files generated, and will require these configuration files once changes are live!"
						unset CUR_NTWRK_END
						WGSCRIPT=true
						WRITEWGS=true
						CHECKWGC=true
					fi
				elif [ -n "$CUR_NTWRK_END" ]; then
					NTWRK_END="$CUR_NTWRK_END"
					unset CUR_NTWRK_END
				else
					NTWRK_END="$(getpriorhost $NTWRK)"
					WGSCRIPT=true
					WRITEWGS=true
					CHECKWGC=true
				fi
#VERIFY WIREGUARD ENDPOINT FOR PEERS
if [ -n "$CUR_ENDPOINT" ]; then
	if [ -z "$ENDPOINT" ]; then
		isip "$CUR_ENDPOINT" && [ -z "$ENDPOINT_IP" ] && ENDPOINT_IP="$(dig +short myip.opendns.com @resolver1.opendns.com)"
		[ -n "$ENDPOINT_IP" ] && [ "$ENDPOINT_IP" != "$CUR_ENDPOINT" ] && err "Detected WAN IP has changed from $CUR_ENDPOINT to $ENDPOINT_IP!\nIf accurate all clients require new configuration files be generated with updated IP!\nRerun script as such to resolve:\n$WGSFULLPATH/$WGSCRIPTNAME --endpoint"
		ENDPOINT="$CUR_ENDPOINT"
		unset CUR_ENDPOINT
	fi
fi
if [ -n "$ENDPOINT" ]; then
	isip "$ENDPOINT" && [ -z "$ENDPOINT_IP" ] && ENDPOINT_IP="$(dig +short myip.opendns.com @resolver1.opendns.com)"
	[ -n "$ENDPOINT_IP" ] && [ "$ENDPOINT_IP" != "$ENDPOINT" ] && err "Detected WAN IP of $ENDPOINT_IP does not match requested $ENDPOINT!\nRerun script as such to resolve:\n$WGSFULLPATH/$WGSCRIPTNAME --endpoint"
	if [ -n "$CUR_ENDPOINT" ] && [ "$CUR_LAN" != "$ENDPOINT" ]; then
		err "Changing endpoint from $CUR_ENDPOINT to $ENDPOINT!\nAll clients require new configuration files be generated, and will require these configuration files once changes are live!"
		unset CUR_ENDPOINT
		WRITEWGS=true
		WRITEWGC=true
	fi
else
	[ -z "$ENDPOINT_IP" ] && ENDPOINT="$(dig +short myip.opendns.com @resolver1.opendns.com)"
	[ -z "$ENDPOINT" ] || ! isip "$ENDPOINT" && errout "No endpoint specified! Could not determine WAN IP!\nRerun script as such with known good information to resolve:\n$WGSFULLPATH/$WGSCRIPTNAME ${@} --endpoint <HOSTNAME/IP>"
	err "No endpoint specified! Detected WAN IP of $ENDPOINT to use as endpoint for clients!"
	WRITEWGS=true
	WRITEWGC=true
fi
#VERIFY DNS SERVER AND CLIENT DNS SERSVER SETTINGS
if [ -n "$NEW_DNS_SRV" ]; then
	if [ -z "$DNS_SRV" ] || [ "$DNS_SRV" != "$NEW_DNS_SRV" ] || [ -n "$CUR_DNS_SRV" ] && [ "$CUR_DNS_SRV" != "$NEW_DNS_SRV" ]; then
		validdns "$NEW_DNS_SRV" || err "Invalid/unreachable DNS from user ($NEW_DNS_SRV)!"
		[ -z "$NEW_DNS_SRV" ] && err "Removing DNS!" || err "Changing DNS from $CUR_DNS_SRV to $NEW_DNS_SRV!"
		err "Clients may need configuration files generated, and will require these configuration files once changes are live!"
		DNS_SRV="$NEW_DNS_SRV"
		unset NEW_DNS_SRV
		WRITEWGS=true
		CHECKWGC=true
	fi
	unset CUR_DNS_SRV
elif [ -n "$DNS_SRV" ]; then
	if [ -n "$CUR_DNS_SRV" ]; then
		if [ "$CUR_DNS_SRV" != "$DNS_SRV" ]; then
			validdns "$DNS_SRV" || err "Invalid/unreachable DNS from script ($DNS_SRV)!"
			[ -z "$DNS_SRV" ] && err "Removing DNS!" || err "Changing DNS from $CUR_DNS_SRV to $DNS_SRV!"
			err "Clients may need configuration files generated, and will require these configuration files once changes are live!"
			DNS_SRV="$CUR_DNS_SRV"
			WRITEWGS=true
			CHECKWGC=true
		fi
		unset CUR_DNS_SRV
	fi
elif [ -n "$CUR_DNS_SRV" ]; then
	validdns "$CUR_DNS_SRV" || err "Invalid/unreachable stored DNS in configuration file ($CUR_DNS_SRV)!"
	DNS_SRV="$CUR_DNS_SRV"
	unset CUR_DNS_SRV
fi
if [ -n "$USE_DNS" ]; then
	torf "$USE_DNS" || errout "USE_DNS variable not true or false from script!"
	if [ $CUR_USE_DNS != $USE_DNS ]; then
		$USE_DNS && err "Clients now set to use DNS server of $DNS_SRV!" || err "Client DNS server no longer enforced!"
		err "Clients may need configuration files generated, and will require these configuration files once changes are live!"
		unset CUR_USE_DNS
		WRITEWGS=true
		CHECKWGC=true
	fi
	$USE_DNS && validdns "$DNS_SRV" || errout "Current DNS server $DNS_SRV is not valid!"
else
	USE_DNS=$CUR_USE_DNS
	unset USE_DNS
fi




[ -n "$MTU" ] && [ $MTU -eq 0 ] && unset MTU
if [ -n "$DNS_SRV" ]; then
	! isip "$DNS_SRV" && errout "Invalid DNS IP!"
	

#PARSE CONFIG FILE [peer] SECTION(S)
if [ -n "$WGC" ] || ALLWGC || CHECKWGC || WRITEWGC && [ ${#WGCONFIG[@]} -ne 0 ]; then
	y=-1
	for x in "${!WGCONFIG[@]}"; do
		! ALLWGC && ! CHECKWGC && ! WRITEWGC && [ -z "$WGC" ] && break 1
		case "${WGCONFIG[$x]}" in
			*\[Peer]*)
				if [ -z "${PEERS[$y]}" ]; then
					#get information
					err "Client in configuration file is not saved correctly!\nAssociated information which is being removed:\n${PEERS[$y]}"
				else
					if ALLWGC || CHECKWGC || WRITEWGC || [ $y -eq -1 ]; then
						y=$((y + 1))
					elif [ -n "$WGC" ] && [[ "$WGC" = *"${PEERS[$y]}"* ]]; then
						WGC="${WGC/${PEERS[$y]}/}"
						WGC="${WGC//, , /, }"
						[[ "$WGC" = ', '* ]] && WGC="${WGC#, *}"
						[[ "$WGC" = *', ' ]] && WGC="${WGC%*, }"
						[ -z "$WGC" ] && break 1 || y=$((y + 1))
					fi
					[ '#' = "${WGCONFIG[$x]::1}" ] && PEERSSTATUSES[$y]='#' || PEERSSTATUSES[$y]=''
				fi;;
			\#peer = *) PEERS[$y]="${WGCONFIG[$x]#\#peer = }";;
			*PublicKey = *) [ -n "${PEERS[$y]}" ] && PEERSPUBKEYS[$y]="${WGCONFIG[$x]#* = }" && [ -z "${PEERSPUBKEYS[$y]}" ] && peererr "$y";;
			\#prekey = *) [ -n "${PEERS[$y]}" ] && PEERSPREKEYS[$y]="${WGCONFIG[$x]#* = }";;
			*PresharedKey = *) [ -n "${PEERS[$y]}" ] && PEERSPREKEYS[$y]="${WGCONFIG[$x]#* = }";;
			*AllowedIPs = *) [ -n "${PEERS[$y]}" ] && PEERSIPS[$y]="${WGCONFIG[$x]#* = }" && PEERSIPS[$y]="${PEERSIPS[$y]%%,*}";;
			*PersistentKeepalive = *) [ -n "${PEERS[$y]}" ] && PEERSALIVES[$y]="${WGCONFIG[$x]#* = }";;
			\#DNS = *) [ -n "${PEERS[$y]}" ] && PEERSDNSS[$y]="${WGCONFIG[$x]#* = }";;
			\#MTU = *) [ -n "${PEERS[$y]}" ] && PEERSMTUS[$y]="${WGCONFIG[$x]#* = }";;
		esac
	done
fi

#LOAD WIREGAURD INTERFACE CONFIGURATION FILE TO MEMORY AND SET VARIABLES OR CREATE FILE
#VERIFY CONFIGURATION FILE CONTINUITY AGAINST SCRIPT SETTINGS, IF DIFFERENT AND CHANGES ACCEPTED BY USER MODIFIES CONFIGURATION FILE TO MATCH SCRIPT


[ "$IFACE" =  "$(defaultinterface)" ]; then
	echo 1>/proc/sys/net/ipv4/ip_forward
	iptables -A INPUT -i LAN-LAN -s 10.9.0.0/24 -j ACCEPT
	iptables -A INPUT -i VPN2 -s 10.10.0.0/24 -j ACCEPT
	iptables -A OUTPUT -o LAN-LAN -s 10.10.0.0/24 -d 10.9.0.0/24 -j ACCEPT
	iptables -A OUTPUT -o VPN2 -s 10.9.0.0/24 -d 10.10.0.0/24 -j ACCEPT
	iptables -A FORWARD -i LAN-LAN -o VPN2 -j ACCEPT
	iptables -A FORWARD -i VPN2 -o LAN-LAN -j ACCEPT
fi

#VERIFY ENDPOINT KEYS
if [ -z $WGS_PRIKEY ]; then
	WRITEWGS=true
	printf "No Wireguard interface private key! Generating new key!" 1>&2
	WGS_PRIKEY=$(wg genkey)
fi
WGS_PUBKEY=$(wg pubkey<<<"$WGS_PRIKEY")


if [ "${WGC}" = "${IFACE}" ]
	then
		if [ -d /sys/class/net/${IFACE} ]
			then
				ip link delete dev ${IFACE}
			fi
		ip link add dev ${IFACE} type wireguard && wg setconf ${IFACE} ${WGSPATH} && exit
		exit 1
	fi
if [ "${2}" = "remove" ]
	then
		if [ -d ${WGCDIR} ]
			then
				printf "${WGC} removed!\n"
				rm -rf ${WGCDIR}
			else
				printf "No Hostname or Username called ${WGC} exists!\n"
			fi
		rm -f ${WGSPATH}
		WGSPATHCREATE
		WGSLIVE ${2} ${3}
	else
		if [ ! -d ${WGCDIR} ]
			then
				mkdir -p ${WGCDIR}
			fi
		if [ -f ${WGCDIR}address ]
			then
				ADDRESS=$(<"${WGCDIR}address")
			else
				ADDRESS=$(echo $NTWRK|cut -d'.' -f1)'.'$(echo $NTWRK|cut -d'.' -f2)'.'$(echo $NTWRK|cut -d'.' -f3)'.'
				WGSFILE=$(<${WGSPATH})
				while echo "${WGSFILE}"|grep -q "${ADDRESS}${NTWRK_BEG}"
					do
						if [ $NTWRK_BEG -eq $NTWRK_END ]
							then
								printf "No available address!\n"
								exit 1
							else
								((NTWRK_BEG=NTWRK_BEG+1))
							fi
				done
				ADDRESS="${ADDRESS}${NTWRK_BEG}"
				printf "${ADDRESS}" > ${WGCDIR}address
				if [ -f ${WGC} ]
					then
						rm -f ${WGC}publickey
					fi
			fi
		if [ ! -f ${WGCDIR}privatekey ] || [ "${2}" = "new" ]
			then
				PRIVKEY=$(wg genkey)
		    		printf "${PRIVKEY}" > ${WGCDIR}privatekey
				if [ -f ${WGCDIR}publickey ]
					then
						rm -f ${WGCDIR}publickey
					fi
				if [ -f ${WGC} ]
					then
						rm -f ${WGC}publickey
					fi
			else
				PRIVKEY=$(<"${WGCDIR}privatekey")
			fi
		if [ ! -f ${WGCDIR}publickey ] || [ "${2}" = "new" ]
			then
				PUBLKEY=$(printf "${PRIVKEY}" | wg pubkey)
				printf "${PUBLKEY}" > ${WGCDIR}publickey
				if [ -f ${WGC} ]
					then
						rm -f ${WGC}publickey
					fi
			else
				PUBLKEY=$(<"${WGCDIR}publickey")
			fi
		if [ ! -f ${WGC} ] || [ "${2}" = "new" ]
			then
				WGCFILE="[Interface]\n\
PrivateKey = $PRIVKEY\n\
PublicKey = $PUBLKEY\n\
Address = $ADDRESS/$(echo $NTWRK|cut -d'/' -f2)\n\
\n\
[Peer]\n\
PublicKey = $SPUBLKEY\n\
AllowedIPs = $NTWRK\n\
Endpoint = $ENDPOINT:$PORT"
				printf "${WGCFILE}" > ${WGC}
			else
				WGCFILE=$(<"${WGC}")
			fi
		if grep -q "$ADDRESS" ${WGSPATH} && [ "${2}" = "new" ]
			then
				rm -f ${WGSPATH}
				WGSPATHCREATE
		elif ! grep -q "$ADDRESS" ${WGSPATH}
			then
				printf "\n\
\n\
[Peer]\n\
PublicKey = $PUBLKEY\n\
AllowedIPs = $ADDRESS/32" >> ${WGSPATH}
			fi
		WGSLIVE ${2} ${3}
		printf "${WGCFILE}\n"
	fi
exit



WGSPATHCREATE() {

	WGSFILE="[Interface]\n\
PrivateKey = ${SPRIVKEY}\n\
PublicKey = ${SPUBLKEY}\n\
ListenPort = ${PORT}"
	if [ -d ${WGSDIR} ]
		then
			for x in $(find ${WGSDIR} -maxdepth 1 -mindepth 1 -type d)
				do
					if [ -f ${x}/publickey ] && [ -f ${x}/address ]
						then
							WGSFILE="$WGSFILE\n\
\n\
[Peer]\n\
PublicKey = $(<${x}/publickey)\n\
AllowedIPs = $(<${x}/address)/32"
						fi
				done
		else
			mkdir -p ${WGSDIR}
		fi
	if [ ! -z $WGSCRIPTPATH_NEW ]
		then
			if [ ! -f ${WGSCRIPTPATH_NEW} ]
				then
					printf "Script moved to: ${WGSCRIPTPATH_NEW}\n"
					cp ${WGSCRIPTPATH} ${WGSCRIPTPATH_NEW}
				fi
			sed -i -e "0,/.*ENDPOINT=.*/ s/.*ENDPOINT=.*/ENDPOINT='${ENDPOINT}'/" ${WGSCRIPTPATH_NEW}
			sed -i -e "0,/.*IFACE=.*/ s/.*IFACE=.*/IFACE='${IFACE}'/" ${WGSCRIPTPATH_NEW}
		fi
	printf "${WGSFILE}" > ${WGSPATH}
}
WGSLIVE () {
	if [ "${2}" = "live" ] || ([ "${1}" = "live" ] && [ -z $3 ])
		then
			if [ -d /sys/class/net/${IFACE} ]
				then
					wg syncconf ${IFACE} ${WGSPATH}
				else
					if [ -z $WGSCRIPTPATH_NEW ]
						then
							printf "Interface ${IFACE} not running!\n\
Start interface with:\n\
${WGSCRIPTPATH} ${IFACE}\n"
						else
							printf "Interface ${IFACE} not running!\n\
Start interface with:\n\
${WGSCRIPTPATH_NEW} ${IFACE}\n"
						fi
				fi
		fi
}

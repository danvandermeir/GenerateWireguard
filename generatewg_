#!/bin/bash
#what VPN peers/"clients" connect to
#if blank attempts to determine WAN IP and changes all client config files if WAN IP has changed
WG_ENDPOINT=''

#if blank uses default port of 51820
WG_ENDPOINT_PORT=''

#name of the local Wireguard interface this script controls
#if blank lowest numbered default name selected (wg0 - wg100)
WG_IFACE_NAME=''

#CIDR format only: X.X.X.X/X
#if blank checks for default LAN and uses next ascending available third octet with lowest available fourth octet
WG_IFACE_NTWRK=''
#peer ip range, ascending order
WG_ADDRESS_RANGE_BEG=''
WG_ADDRESS_RANGE_END=''

#attempt to connect VPN network via NAT to default LAN if false
WG_IFACE_NTWRK_ISOLATE=false
#pass "all" peer traffic through VPN and NAT to default LAN if true, above must be false
WG_IFACE_NTWRK_GATEWAY=false

#
WG_DNS_SEND=false
#gives peers the system default DNS server to use if blank, above must be true
#if using a VPN to pass all traffic a "safe" DNS server should absolutely be considered
WG_DNS=''

#######################################################################################
########## DO NOT EDIT BELOW SCRIPT UNLESS YOU KNOW WHAT YOU'RE DOING, KTHNX ##########
#######################################################################################
WRITEWGSCONF=false
WGSCRIPTNAME="${0##*/}"
WGSCRIPTPATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"

#HELP REQUEST/HOW TO USE
if [ -z $1 ] || [[ $1 =~ '-h'|'-help'|'--help'|'help' ]]; then
	printf "Edit variables in begining of script before running!\n\
\n\
Usage:\n\
$WGSCRIPTPATH <REQUIRED> <OPTION> <LIVE>\n\
\n\
REQUIRED:\n\
\t\t- A hostname or username controlled by this script for this Wireguard interface name.\n\
\t\t  Creates a peer if 'new' OPTION specified. Provides details (config file) for hostname or username.\n\
\n\
\t\t- If Wireguard interface name provided script will stand up or restart the interface using existing configuration.\n\
\n\
OPTION:\n\
\tnew\t- Generate a new private and public key for specified hostname or username and display.\n\
\n\
\tremove\t- Remove peer with specified hostname or username.\n\
\n\
LIVE:\n\
\tlive\t- If provided will update the Wireguard interface with new or removed peer information.\n\
\t\t  Configuration files are otherwise generated for next interface start.\n"
	exit
fi

#VERIFY EXISTANCE OF REQUIRED BINARIES/APPLICATIONS
if ! command -v wg &>/dev/null; then
		printf "Wireguard not available! No path or wrong path? Installed?\n" 1>&2
		exit 1
fi

#DETERMINE WIREGAURD INTERFACE NAME FROM SCRIPT NAME (wireguard_X), SCRIPT PATH, OR CREATES NEW DEFAULT WIREGAURD INTERFACE (wgX) WITH CONFIGURATION FILES
#VERIFY SCRIPT NAME
WGSCRIPTWRITE() {
	local WGSCRIPTPATH_NEW="/etc/wireguard/generatewg_$1"
	if [ ! -f "$WGSCRIPTPATH_NEW" ]; then
		cp "$WGSCRIPTPATH$WGSCRIPTNAME" "$WGSCRIPTPATH_NEW"
		chown root "$WGSCRIPTPATH_NEW"
		chmod 700 "$WGSCRIPTPATH_NEW"
		printf "Script copied to $WGSCRIPTPATH_NEW!\n"
	fi
	printf "Use $WGSCRIPTPATH_NEW instead! Script file can be moved.\n"
}
if [ -z $WG_IFACE_NAME ]; then
	if [ ! "$WGSCRIPTNAME" = "generatewg_" ] && [[ "$WGSCRIPTNAME" == "wireguard_"* ]]; then
		WG_IFACE_NAME="${WGSCRIPTNAME#*_}"
	else
		for x in {0..100}; do
			if [ ! -d /sys/class/net/wg${x} ] && [ ! -f /etc/wireguard/wg${x}.conf ]; then
				WG_IFACE_NAME="wg$x"
				printf "Script WG_IFACE_NAME variable not set!\n\
Script name has no hint!\n\
WG_IFACE_NAME set to $WG_IFACE_NAME!\n"
				WGSCRIPTWRITE "$WG_IFACE_NAME"
				WRITEWGSCONF=true
				break
			fi
		done
	fi
elif [ ! "$WGSCRIPTNAME" = "wireguard_$WG_IFACE_NAME" ]; then
	printf "Script name is improper!\n" 1>&2
	WGSCRIPTWRITE "$WG_IFACE_NAME"
fi

#LOAD WIREGAURD INTERFACE CONFIGURATION FILE TO MEMORY AND SET VARIABLES OR CREATE FILE
WGSCONFFULLPATH="/etc/wireguard/$WG_IFACE_NAME.conf"
WGC="${1// }"
WGCCONFDIR="$WGSDIR$1/"
if [ -f ${WGSCONFFULLPATH} ]; then
	WGSCONF=$(<"$WGSCONFFULLPATH")
	WGCCONF=false
	while IFS="" read -r x || [ -n "$x" ]; do
		if $WGCCONF; then
			case $x in
				\[Peer]*)
					break;;
				\#PrivateKey = *)
					[ -z $WGC_PRIKEY ] && WGC_PRIKEY=${x#\#PrivateKey = };;
				PublicKey = *)
					[ -z $WGC_PUBKEY ] &&  WGC_PUBKEY=${x#PublicKey = };;
				PresharedKey = *)
					[ -z $WGC_PREKEY ] && WGC_PREKEY=${x#PresharedKey = };;
				AllowedIPs = *)
					[ -z $WG_IFACE_NTWRK ] && WG_IFACE_NTWRK=${x//[!0-9\,\/\.]} && WG_IFACE_NTWRK=${WG_IFACE_NTWRK%%,*};;
			esac
		else
			case $x in
				\#Peer = ${WGC}*)
					WGCCONF=true;;
				ListenPort = *)
					[ -z $WG_ENDPOINT_PORT ] && WG_ENDPOINT_PORT=${x//[!0-9]};;
				PrivateKey = *)
					[ -z $WGS_PRIKEY ] && WGS_PRIKEY=${x#PrivateKey = } && WGS_PRIKEY=${WGS_PRIKEY// } && WGS_PUBKEY=$(wg pubkey<<<"$WGS_PRIKEY");;
				PresharedKey = *)
					[ -z $WGS_PREKEY ] && WGS_PREKEY=${x#PresharedKey = } && WGS_PREKEY=${WGS_PREKEY// };;
				Address = *)
					[ -z $WG_IFACE_NTWRK ] && WG_IFACE_NTWRK=${x//[!0-9\,\/\.]} && WG_IFACE_NTWRK=${WG_IFACE_NTWRK%%,*};;
				\#PeerEndpoint = *)
					[ -z $WG_ENDPOINT ] && WG_ENDPOINT=${x#\#PeerEndpoint = } && WG_ENDPOINT=${WG_ENDPOINT// };;
				\#PeerDNS = *)
					[ -z $WG_DNS ] && WG_DNS=${x//[!0-9\/\.]} && WG_DNS=${WG_DNS%%/*};;
				\#RangeBeg = *)
					[ -z $WG_ADDRESS_RANGE_BEG ] && WG_ADDRESS_RANGE_BEG=${x//[!0-9\,\/\.]} && WG_ADDRESS_RANGE_BEG=${WG_ADDRESS_RANGE_BEG%%,*};;
				\#RangeEnd = *)
					[ -z $WG_ADDRESS_RANGE_END ] && WG_ADDRESS_RANGE_END=${x//[!0-9\,\/\.]} && WG_ADDRESS_RANGE_END=${WG_ADDRESS_RANGE_END%%,*};;
			esac
		fi
	done < <(WGSCONF)
else
	WRITEWGSCONF=true
fi

#DETERMINE WIREGAURD INTERFACE IP AND NETWORK FROM SENTINAL FILES, CONFIGURATION FILE, OR CREATE NEW FROM DEFAULT LAN AS TEMPLATE (X.X.Y.1/24)
#VERIFY SENTINAL AND CONFIGURATION FILE CONTINUITY AGAINST SCRIPT SETTING, IF CHANGED MODIFIES ALL "CLIENT"/PEER CONFIGURATION FILES TO MATCH
cidrtomask() {
	if [ -z $1 ] || [[ $1 =~ ^[0-9]+$ ]]; then
		printf "CIDR bit length not provided to cidrtomask function!\n" 1>&2
		exit 1
	fi
	local i='' mask='' full_octets=$(($1/8)) partial_octet=$(($1%8))
	for ((i=0;i<4;i+=1)); do
		if [ $i -lt $full_octets ]; then
			mask+=255
		elif [ $i -eq $full_octets ]; then
			mask+=$((256 - 2**(8-$partial_octet)))
		else
			mask+=0
		fi  
		test $i -lt 3 && mask+=.
	done
	printf "$mask"
}
networkmin() {
	if [ -z $1 ] || [[ *"/"* != "$1" ]]; then
		printf "CIDR network not provided to networkmin function!\n" 1>&2
		exit 1
	fi
	local i1='' i2='' i3='' i4='' m1='' m2='' m3='' m4=''
	IFS=. read -r i1 i2 i3 i4<<<"${1%/*}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask ${1#*/})"
	printf "%d.%d.%d.%d" "$((i1 & m1))" "$((i2 & m2))" "$((i3 & m3))" "$(( ( i4 & m4 ) + 1 ))"
}
networkmax() {
	if [ -z $1 ] || [[ *"/"* != "$1" ]]; then
		printf "CIDR network not provided to networkmax function!\n" 1>&2
		exit 1
	fi
	local i1='' i2='' i3='' i4='' m1='' m2='' m3='' m4=''
	IFS=. read -r i1 i2 i3 i4<<<"${1%/*}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask ${1#*/})"
	printf "%d.%d.%d.%d" "$(( ( 255 ^ m1 ) | i1 ))" "$(( ( 255 ^ m2 ) | i2 ))" "$(( ( 255 ^ m3 ) | i3 ))" "$(( ( ( 255 ^ m4 ) | i4 ) - 1 ))"
}
clientconfignetwork() {
	#WARNING!!!! This function has the potential to "guess" prior existing networks based on "client"/peer configurations wrong!
	local a1='' a2='' a3='' a4='' a5='' check='' lowest='' highest='' laddress='' haddress='' address=''
	if [ -f $WGSCONF ]; then
		while IFS="" read -r x || [ -n "$x" ]; do
			[[ "$x" == "AllowedIPs = "* ]] && a1=${x#AllowedIPs = } && a1=${a1%%,*} && a1=${a1// }
			[[ "$x" == "Address = "* ]] && address=${x#Address = } && address=${address%%,*} && address=${address// }
			[[ "$x" == "#RangeBeg = "* ]] && [ -z $WG_ADDRESS_RANGE_BEG ] && WG_ADDRESS_RANGE_BEG=${x#RangeBeg = } && WG_ADDRESS_RANGE_BEG=${WG_ADDRESS_RANGE_BEG// } && laddress=$WG_ADDRESS_RANGE_BEG
			[[ "$x" == "#RangeEnd = "* ]] && [ -z $WG_ADDRESS_RANGE_END ] && WG_ADDRESS_RANGE_END=${x#RangeEnd = } && WG_ADDRESS_RANGE_END=${WG_ADDRESS_RANGE_END// } && haddress=$WG_ADDRESS_RANGE_END
			[ -n "$address" ] && [ -n "$WG_ADDRESS_RANGE_BEG" ] && [ -n "$WG_ADDRESS_RANGE_END" ] && break
			if [ -n "$a1" ]; then
				a5="${a1#*/}"
				IFS=. read -r a1 a2 a3 a4<<<"${a1%/*}"
				check=$(( a1 + a2 + a3 + a4 ))
				if [ -z $lowest ]; then
					lowest=$check
					highest=$check
				else
					if [ $check -lt $lowest ]; then
						lowest=$check
						laddress="$a1.$a2.$a3.a4/$a5"
					fi
					if [ $check -gt $highest ]; then
						highest=$check
						haddress="$a1.$a2.$a3.a4/$a5"
					fi
				fi
				a1=''
			fi
		done < <(WGSCONF)
		if [ -z $lowest ]; then
			printf 'clientconfignetwork function could not determine any client configurations!\n' 1>&2
			return
		elif [ $lowest = $highest ]; then
			printf 'clientconfignetwork function could not determine network range from client configurations!\n' 1>&2
			return
		else
			lowest=$(networkmin "$laddress")
			a5=${laddress#*/}
			if [ "$lowest" = "$(networkmin $haddress)" ]; then
				highest=$(networkmax "$haddress")
				if [ -z $address ]; then
					IFS=. read -r a1 a2 a3 a4 <<<"${laddress%/*}"
					if [ "$a1.$a2.$a3.$(( a4 - 2 ))" = "$lowest" ]; then
						address="$a1.$a2.$a3.$(( a4 - 1 ))/$a5"
					else
						IFS=. read -r a1 a2 a3 a4 <<<"${haddress%/*}"
						if [ "$a1.$a2.$a3.$(( a4 + 2 ))" = "$highest" ]; then
							address="$a1.$a2.$a3.$(( a4 + 1 ))/$a5"
						else
							printf 'clientconfignetwork function could not determine an interface address!' 1>&2
							return
						fi
					fi
				fi
				IFS=. read -r a1 a2 a3 a4 <<<"${lowest%/*}"
				lowest="$a1.$a2.$a3.$(( a4 + 1 ))/$a5"
				IFS=. read -r a1 a2 a3 a4 <<<"${laddress%/*}"
				a4=$(( a4 - 1 ))
				if [ $a4 -eq $a5 ]; then
					address=
				else
					IFS=. read -r a1 a2 a3 a4 <<<"${laddress%/*}"
					a4=$(( a4 + 1 ))
					if [ $a4 -eq $a5 ]; then

					else
						printf 'clientconfignetwork function could not determine a contigous network! Interfare and clients are not adjacent!\n' 1>&2
						return
					fi
				fi
				if [ -n "$address" ] && [ ! "$lowest" = "$(networkmin $address)" ]; then
				fi



				if [[ *"via"* == "$highest" ]]; then
					a5="${lowest##*.}"
					a5=$(( a5 + 1 ))
					IFS=. read -r a1 a2 a3 a4 <<<"${lowest%/*}"
					if [ $a5 = $a4 ]; then
						address=$lowest
					else
						IFS=. read -r a1 a2 a3 a4 <<< "$highest"
						a5=$(( a4 - 1 ))
						IFS=. read -r a1 a2 a3 a4 <<< $(cut -d'/' -f1 <<< "$haddress")
						if [ $a5 = $a4]; then
							address=$highest
						else
							printf 'clientconfignetwork function could not determine Wiregaurd network!\n' 1>&2
							return
						fi
					fi
				else
					printf 'clientconfignetwork function determined a network that is in use!\n' 1>&2
					return
				fi
			else
				printf 'clientconfignetwork function could not determine a contigous network! The clients are not in the same network!\n' 1>&2
				return
			fi
		fi
	else
		printf 'No Wiregaurd server configuration for clientconfignetwork function!\n' 1>&2
		return
	fi
	printf "$address,$laddress,$haddress"
}
if [ -z $WG_IFACE_NTWRK ]; then
	if [ -n "$WGSCONF" ]; then
		WGCCONF=$(clientconfignetwork)
		if [[ *"/"* == "$WGSCONF" ]]; then
			WG_IFACE_NTWRK="${WGSCONF%%,*}"
			[ -z $WG_ADDRESS_RANGE_BEG ] && WG_ADDRESS_RANGE_BEG="${WGSCONF#*,}" && WG_ADDRESS_RANGE_BEG="${WG_ADDRESS_RANGE_BEG%,*}"
			[ -z $WG_ADDRESS_RANGE_END ] && WG_ADDRESS_RANGE_END="${WGSCONF##*,}"
		else
			printf "Generating new network for Wiregaurd interface!"
		fi
	else
		WG_ADDRESS_RANGE_BEG=$(networkmin "$WG_IFACE_NTWRK")
		if 
		WG_ADDRESS_RANGE_END=$(networkmax "$WG_IFACE_NTWRK")
	fi

x="PrivateKey = 1.1.1.1/24, 2.2.2.2-32,3.3.3.3/20"; echo "${x//[!0-9,/]}"


#clientconfignetwork check server config file?
#bitwise push CIDR mask to a mask with matching end bit

				while [ ! "$address" = "$highest" ]; do
					a5="$(ip route get $address)"
					if [[ *"via"* == "$a5" ]]; then
						IFS=. read -r a1 a2 a3 a4 <<<"$address"
						if [ $a4 -eq 255 ]; then
							a4=0
						else

						fi
					else

					fi
				done



							WG_IFACE_NTWRK=$(???)
							WG_ADDRESS_RANGE_BEG=$(networkmin "$WG_IFACE_NTWRK")
							WG_ADDRESS_RANGE_END=$(networkmax "$WG_IFACE_NTWRK")
					printf "Script WG_IFACE_NTWRK variable not set!\n"
					WG_IFACE_NTWRK=$(ip route show default|rev|cut -d' ' -f1|rev)
					WG_IFACE_NTWRK=$(ip address show "$WG_IFACE_NTWRK"|grep 'inet '|cut -d' ' -f6)
					WG_IFACE_NTWRK="${WG_IFACE_NTWRK//.$WG_ADDRESS_RANGE_BEG./..}"
					WG_ADDRESS_RANGE_BEG=$(cut -d'.' -f4 <<< $WG_IFACE_NTWRK)
					WG_IFACE_NTWRK=${WG_IFACE_NTWRK%$WG_ADDRESS_RANGE_BEG}
					WG_ADDRESS_RANGE_BEG=0
					WG_ADDRESS_RANGE_END=0
					while [ $WG_ADDRESS_RANGE_END -ne 256 ]
						do
							if ! ip route get "${WG_IFACE_NTWRK//../.$WG_ADDRESS_RANGE_BEG.}$WG_ADDRESS_RANGE_END"|grep -q 'via'
								then
									if [ $WG_ADDRESS_RANGE_BEG -eq 255 ]
										then
											printf "Can not determine good network from default LAN!\n" 1>&2
											exit 1
										fi
									WG_ADDRESS_RANGE_BEG=$(( WG_ADDRESS_RANGE_BEG + 1 ))
									WG_ADDRESS_RANGE_END=0
								else
									WG_ADDRESS_RANGE_END=$(( WG_ADDRESS_RANGE_END + 1 ))
								fi
						done
					WG_IFACE_NTWRK="${WG_IFACE_NTWRK//../.$WG_ADDRESS_RANGE_BEG.}1/24"
					WG_ADDRESS_RANGE_BEG=2
					WG_ADDRESS_RANGE_END=254
					print "$WG_IFACE_NTWRK" > ${WGSDIR}address
					print "$WG_ADDRESS_RANGE_BEG" > ${WGSDIR}begin
					print "$WG_ADDRESS_RANGE_END" > ${WGSDIR}end
					printf "WG_IFACE_NTWRK set to $WG_IFACE_NTWRK!\n\
WG_ADDRESS_RANGE_BEG set to $WG_ADDRESS_RANGE_BEG!\n\
WG_ADDRESS_RANGE_END set to $WG_ADDRESS_RANGE_END!\n"






				else
					WG_IFACE_NTWRK=$(grep 'Address = ' <<< "$WGSCONF"|rev|cut -d' ' -f1|rev)
				fi
			printf "${WG_IFACE_NTWRK}">"${WGSDIR}address"
		fi
elif [ ! -f ${WGSDIR}address ] || [ ! "$(<${WGSDIR}address)" = "$WG_IFACE_NTWRK" ]
	then
		print "$WG_IFACE_NTWRK" > ${WGSDIR}address
	fi

#DETERMINE WIREGAURD "CLIENT"/PEER RANGE BEGINING
if [ -z $WG_ADDRESS_RANGE_BEG ]
	then
		if [ -f ${WGSDIR}begin ]
			then
				WG_ADDRESS_RANGE_BEG=$(<"${WGSDIR}begin")
			else
				if [ -z $WGSCONF ]
					then
						printf "Script WG_ADDRESS_RANGE_BEG variable not set!\n" 1>&2
						WG_ADDRESS_RANGE_BEG=$(cut -d'/' -f2 <<< "${WG_IFACE_NTWRK}")
						WG_ADDRESS_RANGE_BEG=$(( 32-WG_ADDRESS_RANGE_BEG ))
						WG_ADDRESS_RANGE_BEG=$(( 2**WG_ADDRESS_RANGE_BEG ))
						WG_ADDRESS_RANGE_END=$(( WG_ADDRESS_RANGE_BEG-1 ))
						while [ $WG_ADDRESS_RANGE_END -lt $WG_ADDRESS_RANGE_BEG ]
							do
								if [ $(( WG_ADDRESS_RANGE_END + 1 )) -eq WGSCONF ]
									then
										####CONTINUE
									fi
								WG_ADDRESS_RANGE_END=$(( WG_ADDRESS_RANGE_END + WG_ADDRESS_RANGE_BEG ))
							done
						if [ $WG_ADDRESS_RANGE_END -eq 255 ]
							then
								printf "Script could not determine netwok address range start for \"clients\"/peers!\n"
								exit 1
							fi
						print "$WG_ADDRESS_RANGE_BEG" > ${WGSDIR}begin
					else
						WG_ADDRESS_RANGE_BEG=$(grep 'RangeBegin = ' <<< "${WGSCONF}"|rev|cut -d' ' -f1|rev)
					fi
			fi
elif [ ! -f ${WGSDIR}begin ] || [ ! "$(<${WGSDIR}begin)" = "$WG_ADDRESS_RANGE_BEG" ]
	then
		print "$WG_ADDRESS_RANGE_BEG" > ${WGSDIR}begin
	fi

if [ -z $WG_ADDRESS_RANGE_END ]
	then
		printf "Script variable WG_ADDRESS_RANGE_END not set!\n" 1>&2
		exit 1
	fi

if [ -f ${WGSCONFPATH}privatekey ]
	then
		SPRIVKEY=$(<"${WGSDIR}privatekey")
	else
		SPRIVKEY=$(wg genkey)
		printf "${SPRIVKEY}" > ${WGSDIR}privatekey
	fi

if [ -f ${WGSCONFPATH}publickey ]
	then
		SPUBLKEY=$(<"${WGSDIR}publickey")
	else
		SPUBLKEY=$(printf "${SPRIVKEY}" | wg pubkey)
		printf "${SPUBLKEY}" > ${WGSDIR}publickey
	fi

if [ -z $WG_ENDPOINT_PORT ]
	then
		WG_ENDPOINT_PORT="51820"
	fi
if [ -z $WG_ENDPOINT ]
	then
		WG_ENDPOINT="$(dig +short myip.opendns.com @resolver1.opendns.com)"
		printf "Script WG_ENDPOINT variable not set!\n\
ENPOINT_HOSTNAME_OR_WANIP set to ${WG_ENDPOINT} on port ${WG_ENDPOINT_PORT}!\n\
All hostname or username config files belonging to Wireguard interface name ${WG_IFACE_NAME} reset!\n"
		if [ -z $WGSCRIPTPATH_NEW ]
			then
				WGSCRIPTPATH_NEW="${WGSCRIPTPATH}"
			fi
		if [ -d ${WGSDIR} ]
			then
				for x in $(find ${WGSDIR} -maxdepth 1 -mindepth 1 -type d)
					do
						WGC=$(printf "${x}"|rev|cut -d'/' -f 1|rev)
						WGCCONF=${x}'/'${WGC}'.conf'
						if [ -f ${WGCCONF} ]
							then
								rm -f ${WGCCONF}
							fi
						if [ -f ${x}/privatekey ] && [ -f ${x}/publickey ] && [ -f ${x}/address ]
							then
								ADDRESS=$(<"${x}/address")
								PUBLKEY=$(<"${x}/publickey")
								PRIVKEY=$(<"${x}/privatekey")
								printf "\t${WGC} - ${ADDRESS} - ${PUBLKEY}\n"
								WGCFILE="[Interface]\n\
PrivateKey = ${PRIVKEY}\n\
PublicKey = ${PUBLKEY}\n\
Address = ${ADDRESS}/$(echo $WG_IFACE_NTWRK|cut -d'/' -f2)\n\
\n\
[Peer]\n\
PublicKey = ${SPUBLKEY}\n\
AllowedIPs = $WG_IFACE_NTWRK\n\
Endpoint = $WG_ENDPOINT:$WG_ENDPOINT_PORT"
								printf "${WGCFILE}" > ${WGCCONF}
							fi
					done
			fi
	fi
WGSCONFPATHCREATE () {
	WGSFILE="[Interface]\n\
PrivateKey = ${SPRIVKEY}\n\
PublicKey = ${SPUBLKEY}\n\
ListenPort = ${WG_ENDPOINT_PORT}"
	if [ -d ${WGSDIR} ]
		then
			for x in $(find ${WGSDIR} -maxdepth 1 -mindepth 1 -type d)
				do
					if [ -f ${x}/publickey ] && [ -f ${x}/address ]
						then
							WGSFILE="$WGSFILE\n\
\n\
[Peer]\n\
PublicKey = $(<${x}/publickey)\n\
AllowedIPs = $(<${x}/address)/32"
						fi
				done
		else
			mkdir -p ${WGSDIR}
		fi
	if [ ! -z $WGSCRIPTPATH_NEW ]
		then
			if [ ! -f ${WGSCRIPTPATH_NEW} ]
				then
					printf "Script moved to: ${WGSCRIPTPATH_NEW}\n"
					cp ${WGSCRIPTPATH} ${WGSCRIPTPATH_NEW}
				fi
			sed -i -e "0,/.*WG_ENDPOINT=.*/ s/.*WG_ENDPOINT=.*/WG_ENDPOINT='${WG_ENDPOINT}'/" ${WGSCRIPTPATH_NEW}
			sed -i -e "0,/.*WG_IFACE_NAME=.*/ s/.*WG_IFACE_NAME=.*/WG_IFACE_NAME='${WG_IFACE_NAME}'/" ${WGSCRIPTPATH_NEW}
		fi
	printf "${WGSFILE}" > ${WGSCONFPATH}
}
WGSLIVE () {
	if [ "${2}" = "live" ] || ([ "${1}" = "live" ] && [ -z $3 ])
		then
			if [ -d /sys/class/net/${WG_IFACE_NAME} ]
				then
					wg syncconf ${WG_IFACE_NAME} ${WGSCONFPATH}
				else
					if [ -z $WGSCRIPTPATH_NEW ]
						then
							printf "Interface ${WG_IFACE_NAME} not running!\n\
Start interface with:\n\
${WGSCRIPTPATH} ${WG_IFACE_NAME}\n"
						else
							printf "Interface ${WG_IFACE_NAME} not running!\n\
Start interface with:\n\
${WGSCRIPTPATH_NEW} ${WG_IFACE_NAME}\n"
						fi
				fi
		fi
}
if [ ! -f ${WGSCONFPATH} ] || [ ! -z $WGSCRIPTPATH_NEW ]
	then
		WGSCONFPATHCREATE
	fi
if [ "${WGC}" = "${WG_IFACE_NAME}" ]
	then
		if [ -d /sys/class/net/${WG_IFACE_NAME} ]
			then
				ip link delete dev ${WG_IFACE_NAME}
			fi
		ip link add dev ${WG_IFACE_NAME} type wireguard && wg setconf ${WG_IFACE_NAME} ${WGSCONFPATH} && exit
		exit 1
	fi
if [ "${2}" = "remove" ]
	then
		if [ -d ${WGCCONFDIR} ]
			then
				printf "${WGC} removed!\n"
				rm -rf ${WGCCONFDIR}
			else
				printf "No Hostname or Username called ${WGC} exists!\n"
			fi
		rm -f ${WGSCONFPATH}
		WGSCONFPATHCREATE
		WGSLIVE ${2} ${3}
	else
		if [ ! -d ${WGCCONFDIR} ]
			then
				mkdir -p ${WGCCONFDIR}
			fi
		if [ -f ${WGCCONFDIR}address ]
			then
				ADDRESS=$(<"${WGCCONFDIR}address")
			else
				ADDRESS=$(echo $WG_IFACE_NTWRK|cut -d'.' -f1)'.'$(echo $WG_IFACE_NTWRK|cut -d'.' -f2)'.'$(echo $WG_IFACE_NTWRK|cut -d'.' -f3)'.'
				WGSFILE=$(<${WGSCONFPATH})
				while echo "${WGSFILE}"|grep -q "${ADDRESS}${WG_ADDRESS_RANGE_BEG}"
					do
						if [ $WG_ADDRESS_RANGE_BEG -eq $WG_ADDRESS_RANGE_END ]
							then
								printf "No available address!\n"
								exit 1
							else
								((WG_ADDRESS_RANGE_BEG=WG_ADDRESS_RANGE_BEG+1))
							fi
				done
				ADDRESS="${ADDRESS}${WG_ADDRESS_RANGE_BEG}"
				printf "${ADDRESS}" > ${WGCCONFDIR}address
				if [ -f ${WGCCONF} ]
					then
						rm -f ${WGCCONF}publickey
					fi
			fi
		if [ ! -f ${WGCCONFDIR}privatekey ] || [ "${2}" = "new" ]
			then
				PRIVKEY=$(wg genkey)
		    		printf "${PRIVKEY}" > ${WGCCONFDIR}privatekey
				if [ -f ${WGCCONFDIR}publickey ]
					then
						rm -f ${WGCCONFDIR}publickey
					fi
				if [ -f ${WGCCONF} ]
					then
						rm -f ${WGCCONF}publickey
					fi
			else
				PRIVKEY=$(<"${WGCCONFDIR}privatekey")
			fi
		if [ ! -f ${WGCCONFDIR}publickey ] || [ "${2}" = "new" ]
			then
				PUBLKEY=$(printf "${PRIVKEY}" | wg pubkey)
				printf "${PUBLKEY}" > ${WGCCONFDIR}publickey
				if [ -f ${WGCCONF} ]
					then
						rm -f ${WGCCONF}publickey
					fi
			else
				PUBLKEY=$(<"${WGCCONFDIR}publickey")
			fi
		if [ ! -f ${WGCCONF} ] || [ "${2}" = "new" ]
			then
				WGCFILE="[Interface]\n\
PrivateKey = $PRIVKEY\n\
PublicKey = $PUBLKEY\n\
Address = $ADDRESS/$(echo $WG_IFACE_NTWRK|cut -d'/' -f2)\n\
\n\
[Peer]\n\
PublicKey = $SPUBLKEY\n\
AllowedIPs = $WG_IFACE_NTWRK\n\
Endpoint = $WG_ENDPOINT:$WG_ENDPOINT_PORT"
				printf "${WGCFILE}" > ${WGCCONF}
			else
				WGCFILE=$(<"${WGCCONF}")
			fi
		if grep -q "$ADDRESS" ${WGSCONFPATH} && [ "${2}" = "new" ]
			then
				rm -f ${WGSCONFPATH}
				WGSCONFPATHCREATE
		elif ! grep -q "$ADDRESS" ${WGSCONFPATH}
			then
				printf "\n\
\n\
[Peer]\n\
PublicKey = $PUBLKEY\n\
AllowedIPs = $ADDRESS/32" >> ${WGSCONFPATH}
			fi
		WGSLIVE ${2} ${3}
		printf "${WGCFILE}\n"
	fi
exit

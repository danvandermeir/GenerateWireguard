#!/bin/bash

#hostname or IP that peers ("clients") connect to, save yourself trouble and utilize a DNS name
#if blank attempts to determine WAN IP, if a WAN IP (or blank) and actual IP changes all peers ("clients") must be updated!
ENDPOINT=''
#port that peers ("clients") connect to, recommend changing from default (consult list of ports, Wiki?)
#if blank uses default port of 51820, ascends if used
PORT=''
#disconnect peers ("clients") and endpoint from LAN when true instead of false
#overriden by GATEWAY=true, if peer ("client") network conflict traffic is mostly routed to endpoint
ISOLATE=false
#peers ("clients") pass "all" traffic to endpoint's LAN route when true instead of false
#when true absolutely consider setting USE_DNS to true and selecting a "safe" DNS server for DNS_SRV!
GATEWAY=false

#######################################################
########## ADVANCED AND/OR OPTIONAL FEATURES ##########
#######################################################

#WireGuard interface this script controls
#if blank uses default of wg0 - wg255, ascends if used
#if blank and script doesn't contain interface name a new interface and script file will be generated (generatewg_$IFACE)
IFACE=''
#IP and network of the local Wireguard interface, CIDR format only: X.X.X.X/X
#if blank checks LAN for network, ascends networks if used
NTWRK=''
#peer ip range, CIDR format only: X.X.X.X/X
#if blank ascends from NTWRK, wraps, and ends at NTWRK_END or NTWRK
NTWRK_BEG=''
NTWRK_END=''
#attach VPN to this "LAN" interface name
#if blank uses system default network (network usually includes a NAT to the internet, routable only if GATEWAY=true)
LAN=''
#comma+space seperated list of CIDR LAN networks ('X.X.X.X/X, Y.Y.Y.Y/Y, Z.Z.Z.Z/Z') to attach VPN to
#peers ("clients") will route to and from these networks over endpoint in addition to NTWRK and LAN
ROUTES=''
#peers ("clients") will use DNS_SRV for DNS server(s) when true instead of false
USE_DNS=false
#if blank uses enpoint system's DNS server (USE_DNS must be true)
DNS_SRV=''
#base64 symmetric-key crypto is mixed with public key crypto for post-quantum resistance when true instead of false
#if false may lower CPU usage, perhaps a tiny boost in latency/speed as a result
USEPREKEY=true
#1-65535 seconds between empty encrypted packet sends by peers ("clients")
#if blank or 0 this is disabled
KEEPALIVE=300

NTWRK_MTU=''

PREUP=''

POSTUP=''

PREDOWN=''

POSTDOWN=''

########################################################################################
########## DO NOT EDIT BELOW SCRIPT UNLESS YOU KNOW WHAT YOU ARE DOING, KTHNX ##########
########################################################################################

err() {
	[ -n "$1" ] && printf -- "$1\n" 1>&2 && return 0
	return 1
}
errout() {
	err "$1"
	exit 1
}

#VERIFY EXISTANCE OF REQUIRED BINARIES/APPLICATIONS
BINARIES=('wg' 'ip')
for x in "${!BINARIES[@]}"; do
	BINARIES[$x]="$(command -v ${BINARIES[$x]})" || errout "Required binaries (applications) not available!"
done

#SET DEFAULTS FOR SCRIPT RUN
WRITEWGS=false
WGSUPDATE=false
WGCSTATUS='#'
WRITEWGC=false
SHOWALLWGC=false
CHECKALLWGC=false
WRITEALLWGC=false
WGSCRIPTNAME="${0##*/}"
WGSCRIPTPATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)/"
istorf() {
	[ $1 = true ] || [ $1 = false ] && return 0
	err "Not true or false ($1)!" && return 1
}
isnum() {
	[ -z "$1" ] || ! [[ $1 =~ ^[0-9]+$ ]] && err "Invalid numbers ($1)!" && return 1
	return 0
}
validlngth() {
	! [ -n "$1" ] || [ ${#1} -gt 63 ] && err "Invalid character length ($1)!" && return 1
	return 0
}
validchrs() {
	[ -z "$1" ] || ! [[ $1 =~ ^[[ $1 =~ ^[A-Za-z0-9\.\-\_]+$ ]] && err "Invalid characters ($1)! Must be alphanumeric, period (.), minus (-), or underscore (_)!" && return 1
	return 0
}
validchrssyn() {
	! [ -n "$1" ] || ! validlngth "$1" || ! validchrs "$1" && return 1
	return 0
}
validdns() {
	[ -z "$1" ] && err "validdns function not provided a server to test!" && return 1
	dig +time=2 +tries=2 +retry=0 +short @"$1" A dns.opendns.com &> /dev/null && return 0
	return 1
}
isport() {
	[ -z "$1" ] || ! isnum "$1" || [ $1 -lt 1 ] || [ $1 -gt 65535 ] && err "Invalid port ($1)!" && return 1
	return 0
}
isip() {
	[ -z "$1" ] || [[ ! $1 =~ ^[0-9/.]+$ ]] && err "Invalid IP address ($1)!" && return 1
	local a1 a2 a3 a4 v
	a4="$1"
	a1=${a4//.}
	[ $((${#a4} - ${#a1})) -ne 3 ] && err "Invalid IP address ($1)!" && return 1
	for y in {1..4}; do
		declare a$y="${a4%%.*}"
		v="a$y"
		[ -z "${!v}" ] || [ ${!v} -gt 255 ] && err "Invalid IP address ($1)!" && return 1
		a4="${a4#*.}"
	done
	return 0
}
ismultiip() {
	local x y
	x="$1"
	while [ -n "$x" ]; do
		y="${x%%, *}"
		! isip "$y" && return 1
		x="${x#$y, }"
	done
	return 0
}
isprivateip() {
	[ -z "$1" ] || ! isip "$1" && return 1
	#check if IP is in private ranges
	return 0
}
iscidr() {
	[ -z "$1" ] || [[ ! $1 =~ ^[0-9/./\/]+$ ]] || ! isip "${1%/*}" && err "Invalid CIDR address ($1)!" && return 1
	local m1
	m1="${1#*/}"
	[ -z "$m1" ] || ! isnum "$m1" || [ $m1 -lt 8 ] || [ $m1 -gt 32 ] && err "Invalid CIDR address ($1)!" && return 1
	return 0
}
ismulticidr() {
	local x y
	x="$1"
	while [ -n "$x" ]; do
		y="${x%%, *}"
		! iscidr "$y" && return 1
		x="${x#$y, }"
	done
	return 0
}
GETARGS() {
	#present function call with getopts like interface
	local FLGVARNAME ARGVARNAME CURARG
	FLGVARNAME="FLG$$"
	ARGVARNAME="ARG$$"
	if [ -n "${!FLGVARNAME}" ]; then
		eval "${!FLGVARNAME}"
		eval "${!ARGVARNAME}"
	fi
	if declare -p FLG&>/dev/null; then
		if [ "${#FLG[@]}" -eq 0 ]; then
			unset $FLGVARNAME $ARGVARNAME $2 OPTARG
			return 1
		else
			for CURARG in "${!FLG[@]}"; do
				if [ $CURARG -eq 0 ]; then
					eval export "$2"="${FLG[0]}"
				else
					FLG[$((CURARG - 1))]="${FLG[$CURARG]}"
				fi
				unset FLG[$CURARG]
			done
			if [ ${#ARG[@]} -eq 0 ]; then
				unset OPTARG
			else
				[ -z "${ARG[0]}" ] && unset OPTARG
				for CURARG in "${!ARG[@]}"; do
					if [ $CURARG -eq 0 ]; then
						[ -n "${ARG[0]}" ] && export OPTARG="${ARG[0]}"
					else
						ARG[$((CURARG - 1))]="${ARG[$CURARG]}"
					fi
					unset ARG[$CURARG]
				done
			fi
			CURARG='$(declare -p FLG)'
			eval $FLGVARNAME="$CURARG"
			CURARG='$(declare -p ARG)'
			eval $ARGVARNAME="$CURARG"
			return 0
		fi
	fi
	local ALLFLGS SHRTFLGS TMPSHRTFLGS TMPLNGFLGS CURFLG TMP1 TMP2 REQARGS NOREQARGS ERRHNDL
	#input sanitize, build lists of accepted flags, then build array based on presented arguements and accepted flags
	ALLFLGS="$1"
	while [[ "$ALLFLGS" == *'::'* ]]; do
		ALLFLGS="${ALLFLGS/::/:}"
	done
	while [[ "$ALLFLGS" == *',,'* ]]; do
		ALLFLGS="${ALLFLGS/,,/,}"
	done
	while [[ "$ALLFLGS" == *'---'* ]]; do
		ALLFLGS="${ALLFLGS/---/--}"
	done
	TMPLNGFLGS="--${ALLFLGS#*--}"
	SHRTFLGS="${ALLFLGS%%--*}"
	SHRTFLGS="${SHRTFLGS//-/}"
	TMPSHRTFLGS="$SHRTFLGS"
	if [ "${SHRTFLGS::1}" = ':' ]; then
		SHRTFLGS="${SHRTFLGS:1}"
		ERRHNDL=true
	else
		ERRHNDL=false
	fi
	CURFLG=0
	REQARGS=''
	NOREQARGS=''
	for CURARG in "${@:3}"; do
		if [ "$CURARG" = '-' ] || [ "$CURARG" = '--' ]; then
			if $ERRHNDL; then
				local FLG[$CURFLG] ARG[$CURFLG]
				FLG[$CURFLG]='?'
				ARG[$CURFLG]="$CURARG"
				CURFLG=$((CURFLG + 1))
				continue 1
			else
				printf -- "$CURARG is invalid!\n" >&2
				return 1
			fi
		fi
		if [[ "$CURARG" == '-'* ]]; then
				if [ -n "$REQARGS" ]; then
					if $ERRHNDL; then
						while [ -n "$REQARGS" ]; do
							TMP1="${REQARGS%%,*}"
							local ARG[$TMP1]
							ARG[$TMP1]="${FLG[$TMP1]}"
							FLG[$TMP1]='?'
							REQARGS="${REQARGS#$TMP1,}"
						done
					else
						TMP1="${REQARGS%%,*}"
						printf -- "${FLG[$TMP1]} no supplied arguement!\n" >&2
						return 1
					fi
				fi
			if [[ "$CURARG" == '--'* ]]; then
				if [[ "$ALLFLGS" != *"$CURARG"* ]]; then
					if $ERRHNDL; then
						local FLG[$CURFLG] ARG[$CURFLG]
						FLG[$CURFLG]="?"
						ARG[$CURFLG]="$CURARG"
						CURFLG=$((CURFLG + 1))
						continue 1
					else
						printf -- "$CURARG is invalid flag!\n" >&2
						return 1
					fi
				fi
				if [[ "$TMPLNGFLGS" = *"$CURARG"* ]]; then
					TMP2="$TMPLNGFLGS"
					while [ -n "$TMP2" ]; do
						if [[ "$TMP2" = "$CURARG"* ]]; then
							local FLG[$CURFLG]
							FLG[$CURFLG]="$CURARG"
							TMP2="${TMP2#$CURARG}"
							if [ "${TMP2::1}" = ':' ]; then
								[ "${TMP2:1:1}" != ',' ] && TMPLNGFLGS="${TMPLNGFLGS/$CURARG:}"
								REQARGS="$REQARGS$CURFLG,"
							elif [ "${TMP2::1}" = ',' ]; then
								if [ "${TMP2:1:1}" = ':' ]; then
									REQARGS="$REQARGS$CURFLG,"
								else
									NOREQARGS="$NOREQARGS$CURFLG,"
								fi
							else
								TMPLNGFLGS="${TMPLNGFLGS/$CURARG:}"
								NOREQARGS="$NOREQARGS$CURFLG,"
							fi
							CURFLG=$((CURFLG + 1))
							break 1
						else
							TMP2="${TMP2:2}"
							TMP2="--${TMP2#*--}"
						fi
					done
				elif $ERRHNDL; then
					local FLG[$CURFLG] ARG[$CURFLG]
					FLG[$CURFLG]="?"
					ARG[$CURFLG]="$CURARG"
					CURFLG=$((CURFLG + 1))
					continue 1
				else
					printf -- "$CURARG cannot be used again!\n" >&2
					return 1
				fi
			else
				CURARG="${CURARG:1}"
				while [ -n "$CURARG" ]; do
					TMP1="${CURARG::1}"
					CURARG="${CURARG:1}"
					if [[ "$SHRTFLGS" != *"$TMP1"* ]]; then
						if $ERRHNDL; then
							local FLG[$CURFLG] ARG[$CURFLG]
							FLG[$CURFLG]="?"
							ARG[$CURFLG]="-$TMP1"
							CURFLG=$((CURFLG + 1))
							continue 1
						else
							printf -- "-$TMP1 is invalid flag!\n" >&2
							return 1
						fi
					fi
					if [[ "$TMPSHRTFLGS" = *"$TMP1"* ]]; then
						TMP2="$TMPSHRTFLGS"
						while [ -n "$TMP2" ]; do
							if [[ "$TMP2" = "$TMP1"* ]]; then
								local FLG[$CURFLG]
								FLG[$CURFLG]="$TMP1"
								TMP2="${TMP2:1}"
								TMP1="${TMP2::1}"
								if [ "$TMP1" = ':' ]; then
									[ "${TMP2:1:1}" != ',' ] && TMPSHRTFLGS="${TMPSHRTFLGS/${FLG[$CURFLG]}:}"
									REQARGS="$REQARGS$CURFLG,"
								elif [ "$TMP1" = ',' ]; then
									if [ "${TMP2:1:1}" = ':' ]; then
										REQARGS="$REQARGS$CURFLG,"
									else
										NOREQARGS="$NOREQARGS$CURFLG,"
									fi
								else
									TMPSHRTFLGS="${TMPSHRTFLGS/${FLG[$CURFLG]}}"
									NOREQARGS="$NOREQARGS$CURFLG,"
								fi
								FLG[$CURFLG]="-${FLG[$CURFLG]}"
								CURFLG=$((CURFLG + 1))
								break 1
							else
								TMP2="${TMP2:1}"
							fi
						done
					elif $ERRHNDL; then
						local FLG[$CURFLG] ARG[$CURFLG]
						FLG[$CURFLG]="?"
						ARG[$CURFLG]="-$TMP1"
						NOREQARGS="$NOREQARGS$CURFLG,"
						CURFLG=$((CURFLG + 1))
						continue 1
					else
						printf -- "-$TMP1 cannot be used again!\n" >&2
						return 1
					fi
				done
			fi
		elif [ -n "$REQARGS" ]; then
			TMP1="${REQARGS%%,*}"
			local ARG[$TMP1]
			ARG[$TMP1]="$CURARG"
			REQARGS="${REQARGS#$TMP1,}"
			NOREQARGS="$NOREQARGS$TMP1,"
		elif [ -z "${FLG[0]}" ]; then
			if $ERRHNDL; then
				local FLG[$CURFLG] ARG[$CURFLG]
				FLG[$CURFLG]="?"
				ARG[$CURFLG]="$CURARG"
				CURFLG=$((CURFLG + 1))
			else
				printf -- "$CURARG is not a flag!\n" >&2
				return 1
			fi
		elif [ -z "$REQARGS" ]; then
			if $ERRHNDL; then
				local FLG[$CURFLG] ARG[$CURFLG]
				FLG[$CURFLG]='?'
				if [[ "$NOREQARGS" = *"$((CURFLG - 1))"* ]]; then
					ARG[$CURFLG]="$CURARG"
					NOREQARGS="$NOREQARGS$CURFLG,"
				elif [ "${FLG[$((CURFLG - 1))]}" = '?' ]; then
					ARG[$CURFLG]="${ARG[$((CURFLG - 1))]}"
				else
					ARG[$CURFLG]="${FLG[$((CURFLG - 1))]}"
				fi
				CURFLG=$((CURFLG + 1))
			else
				printf -- "${FLG[$((CURFLG - 1))]} over supplied arrguements!\n" >&2
				return 1
			fi
		fi
	done
	if [ -n "$REQARGS" ]; then
		if $ERRHNDL; then
			while [ -n "$REQARGS" ]; do
				TMP1="${REQARGS%%,*}"
				local ARG[$TMP1]
				ARG[$TMP1]="${FLG[$TMP1]}"
				FLG[$TMP1]='?'
				REQARGS="${REQARGS#$TMP1,}"
			done
		else
			TMP1="${REQARGS%%,*}"
			printf -- "${FLG[$TMP1]} no supplied arguement!\n" >&2
			return 1
		fi
	fi
	#first output to function call location
	if [ -n "${FLG[0]}" ]; then
		for REQARGS in "${!FLG[@]}"; do
			if [ $REQARGS -eq 0 ]; then
				eval export "$2"="${FLG[0]}"
			else
				FLG[$((REQARGS - 1))]="${FLG[$REQARGS]}"
			fi
			unset FLG[$REQARGS]
		done
		if [ ${#ARG[@]} -ne 0 ]; then
			[ -z "${ARG[0]}" ] && unset OPTARG
			for REQARGS in "${!ARG[@]}"; do
				if [ $REQARGS -eq 0 ]; then
					[ -n "${ARG[0]}" ] && export OPTARG="${ARG[0]}"
				else
					ARG[$((REQARGS - 1))]="${ARG[$REQARGS]}"
				fi
				unset ARG[$REQARGS]
			done
		fi
		REQARGS='$(declare -p FLG)'
		eval export $FLGVARNAME="$REQARGS"
		REQARGS='$(declare -p ARG)'
		eval export $ARGVARNAME="$REQARGS"
		return 0
	else
		return 1
	fi
}
cidrtomask() {
	[ -z "$1" ] || [[ ! $1 =~ ^[0-9]+$ ]] || [ $1 -lt 8 ] || [ $1 -gt 32 ] && errout "CIDR bit length not provided to cidrtomask function (expected 8-32, got '$1')!"
	local i mask full part
	full=$(($1/8))
	part=$(($1%8))
	for ((i=0;i<4;i+=1)); do
		if [ $i -lt $full ]; then
			mask+=255
		elif [ $i -eq $full ]; then
			mask+=$((256 - 2**(8-$part)))
		else
			mask+=0
		fi
		test $i -lt 3 && mask+=.
	done
	printf "$mask"
	return 0
}
networkmin() {
	 [ -z $1 ] || ! iscidr "$1" && errout 'CIDR address not provided to networkmin function!'
	local a1 a2 a3 a4 m1 m2 m3 m4
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask ${1#*/})"
	a1=$((a1 & m1))
	a2=$((a2 & m2))
	a3=$((a3 & m3))
	a4=$((a4 & m4))
	printf "$a1.$a2.$a3.$a4"
	return 0
}
networkmax() {
	[ -z $1 ] || ! iscidr "$1" && errout 'CIDR address not provided to networkmax function!'
	local a1 a2 a3 a4 m1 m2 m3 m4
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask ${1#*/})"
	a1=$((( 255 ^ m1 ) | a1 ))
	a2=$((( 255 ^ m2 ) | a2 ))
	a3=$((( 255 ^ m3 ) | a3 ))
	a4=$((( 255 ^ m4 ) | a4 ))
	printf "$a1.$a2.$a3.$a4"
	return 0
}
getnextnetwork() {
	[ -z $1 ] || ! iscidr "$1" && errout "CIDR network not provided to getnextnetwork function!"
	local a1 a2 a3 a4 a5 a6 h1 h2 h3 h4 m1 m2 m3 m4 address
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	a5=${1#*/}
	a6=$((32 - a5))
	h1=$a1
	h2=$a2
	h3=$a3
	h4=$a4
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask $a5)"
	address=$((((((((((a1 << 8) | a2) << 8) | a3) << 8) | a4) >> a6) + 1) << a6 ))
	a4=$(( ((255 & address) & m4) | (h4 & (255 ^ m4)) ))
	address=$((address >> 8))
	a3=$(( ((255 & address) & m3) | (h3 & (255 ^ m3)) ))
	address=$((address >> 8))
	a2=$(( ((255 & address) & m2) | (h2 & (255 ^ m2)) ))
	address=$((address >> 8))
	a1=$(( ((255 & address) & m1) | (h1 & (255 ^ m1)) ))
	[ $h1 -eq 10 ] && [ $a1 -ne 10 ] && a1=10
	[ "$h1$h2" = "192168" ] && [ "$a1$a2" != "192168" ] && a1=192 && a2=168
	[ "$h1$h2" = "169254" ] && [ "$a1$a2" != "169254" ] && a1=169 && a2=254
	[ $a1 -eq 172 ] && [ $a2 -gt 31 ] && a2=16
	printf "$a1.$a2.$a3.$a4/$a5"
	return 0
}
getpriorhost() {
	[ -z $1 ] || ! iscidr "$1" && errout "CIDR address not provided to getpriorhost function!"
	local a1 a2 a3 a4 a5 m1 m2 m3 m4 i1 i2 i3 i4 address
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	a5="${1#*/}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask $a5)"
	i1=$((255 ^ m1))
	i2=$((255 ^ m2))
	i3=$((255 ^ m3))
	i4=$((255 ^ m4))
	address=$((((((((a1 << 8) | a2) << 8) | a3) << 8) | a4) - 1))
	a4=$((((255 & address) & i4) | (a4 & m4)))
	address=$((address >> 8))
	a3=$((((255 & address) & i3) | (a3 & m3)))
	address=$((address >> 8))
	a2=$((((255 & address) & i2) | (a2 & m2)))
	a1=$((((address >> 8) & i1) | (a1 & m1)))
	address="$a1.$a2.$a3.$a4"
	[ "$address" = '0.0.0.0' ] || [ "$address" = '255.255.255.255' ] || [ "$address" = "$(networkmin $address/$a5)" ] || [ "$address" = "$(networkmax $address/$a5)" ] && address="$(getpriorhost $address/$a5)"
	printf "$address"
	return 0
}
getnexthost() {
	[ -z $1 ] || ! iscidr "$1" && errout "CIDR address not provided to getnexthost function!"
	local a1 a2 a3 a4 a5 m1 m2 m3 m4 i1 i2 i3 i4 address
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	a5="${1#*/}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask $a5)"
	i1=$((255 ^ m1))
	i2=$((255 ^ m2))
	i3=$((255 ^ m3))
	i4=$((255 ^ m4))
	address=$((((((((a1 << 8) | a2) << 8) | a3) << 8) | a4) + 1))
	a4=$((((255 & address) & i4) | (a4 & m4)))
	address=$((address >> 8))
	a3=$((((255 & address) & i3) | (a3 & m3)))
	address=$((address >> 8))
	a2=$((((255 & address) & i2) | (a2 & m2)))
	a1=$((((address >> 8) & i1) | (a1 & m1)))
	address="$a1.$a2.$a3.$a4"
	[ "$address" = '0.0.0.0' ] || [ "$address" = '255.255.255.255' ] || [ "$address" = "$(networkmin $address/$a5)" ] || [ "$address" = "$(networkmax $address/$a5)" ] && address="$(getnexthost $address/$a5)"
	printf "$address"
	return 0
}
#################                                               NEEDS FIX!!!
rangeunused() {
	[ -z "$1" ] || ! iscidr "$1" && err "CIDR network not provided to rangeunused function ($1)!" && return 1
	local a1 a2 a3 a4 a5 cur max address
	address="$(networkmin $1)"
	#nmap check && return 1
	#icmp check && return 1
	IFS=. read -r a1 a2 a3 a4<<<"$(networkmax $1)"
	max=$(( ( a1 << 24 ) + ( a2 << 16 ) + ( a3 << 8 ) + a4 ))
	IFS=. read -r a1 a2 a3 a4<<<"$address"
	a5=${1#*/}
	while [[ "$(ip route get $a1.$a2.$a3.$a4/$a5)" == *"via"* ]] || return 1; do
		cur=$(( ( a1 << 24 ) + ( a2 << 16 ) + ( a3 << 8 ) + a4 ))
		[ $cur -eq $max ] && break
		a4=$(( a4 + 1 ))
		[ $a4 -eq 256 ] && a4=0 && a3=$(( a3 + 1 ))
		[ $a3 -eq 256 ] && a3=0 && a2=$(( a2 + 1 ))
		[ $a2 -eq 256 ] && a2=0 && a1=$(( a1 + 1 ))
		[ $a1 -eq 256 ] && a1=0
	done
	return 0
}
inrange() {
	[ -z "$1" ] || [ -z "$2" ] || ! isip "$1" || ! iscidr "$2" && errout "IP and CIDR not provided to inrange function (got '$1' and '$2')!"
	[ "$(networkmin $1/${2#*/})" = "$(networkmin $2)" ] && return 0
	return 1
}
ifaceunused() {
	[ -z "$1" ] || [ -d "/sys/class/net/$1" ] && return 1
	return 0
}
getcidrof() {
	local address
	address=$(ip address show "$1" 2>/dev/null|grep 'inet ')
	address=${address#*inet }
	address=${address%% *}
	[ -z "$1" ] || [ -z "$address" ] || ! iscidr "$address" && err "getcidrof function provided invalid interface name ($1)!" && return 1
	printf "$(networkmin $address)/${address#*/}"
	return 0
}
generatenetworkfrom() {
	local address nextaddress
	if [ -n "$1" ]; then
		err "Attempting to generate a network from $1 interface!"
		address=$(getcidrof "$1")
	fi
	if [ -z $address ]; then
		address=$(ip route show default)
		address=${address#* dev }
		address=${address%% *}
		err "Attempting to generate a network from default $address interface!"
		address=$(getcidrof "$address")
	fi
	! iscidr "$address" && errout 'generatenetworkfrom function could find network to generate from!'
	nextaddress=$(getnextnetwork "$address")
	while ! rangeunused "$nextaddress"; do
		nextaddress=$(getnextnetwork "$nextaddress")
		[ "$address" = "$nextaddress" ] && errout "generatenetworkfrom function could not determine an unused network!"
	done
	printf "$nextaddress"
	return 0
}
#################                                               NEEDS FIX!!!
clientconfignetwork() {
	#WARNING!!!! This function has the potential to "guess" prior existing networks based on peer configurations wrong!
		err "Attempting to determine $IFACE network from peers in configuration file!"
	local a1 a2 a3 a4 a5 a6 check lowest highest address generated
	if [ -n "$WGS" ]; then
		while IFS= read -r x || [ -n "$x" ]; do
			if [[ "$x" == "AllowedIPs = "* ]]; then
				address=${x//[!0-9\,\/\.]}
				address=${address%%,*}
				address=${address%/*}
				IFS=. read -r a1 a2 a3 a4<<<"$address"
			check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
				if [ -z $lowest ]; then
					lowest=$check
					highest=$check
				elif [ $check -lt $lowest ]; then
					lowest=$check
				elif [ $check -gt $highest ]; then
					highest=$check
				fi
			fi
		done <<< "$WGS"
		[ -z $lowest ] && errout 'clientconfignetwork function could not determine any peer configurations!'
	else
		errout 'No Wiregaurd server configuration for clientconfignetwork function!'
	fi
	printf 'clientconfignetwork function attempting to match an existing network to Wireguard configuration file peers!\n' 1>&2
	a6=$(generatenetworkfrom $1)
	generated=$(getnexthost $a6)
	IFS=. read -r a1 a2 a3 a4<<<"${generated%/*}"
	check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
	if [ $check -eq $lowest ] || [ $check -eq $((lowest - 1)) ]; then
		printf 'clientconfignetwork function matched a network for Wireguard configuration file peers! Verify network in configuration file!\n' 1>&2
		printf "$a6"
	else
		printf 'clientconfignetwork function attempting to guess network for Wireguard configuration file peers!\n' 1>&2
		for x in {30..8}; do
			IFS=. read -r a1 a2 a3 a4<<<"$(networkmin $address/$x)"
			a5="$a1.$a2.$a3.$((a4 + 1))"
			check=$((((a1 << 24) + (a2 << 16) + (a3 << 8) + a4) + 2))
			if [ $check -eq $lowest ]; then
				IFS=. read -r a1 a2 a3 a4<<<"$(networkmax $address/$x)"
				check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
				[ $check -gt $highest ] && address="$a5/$x" && a5=$x && break
			else
				IFS=. read -r a1 a2 a3 a4<<<"$(networkmax $address/$x)"
				generated="$a1.$a2.$a3.$((a4 - 1))"
				check=$((((a1 << 24) + (a2 << 16) + (a3 << 8) + a4) - 2))
				if [ $check -eq $highest ]; then
					IFS=. read -r a1 a2 a3 a4<<<"$a5"
					check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
					[ $check -le $lowest ] && address="$generated/$x" && a5=$x && break
				fi
			fi
			a5=''
		done
		if [ -z $a5 ]; then
			printf 'clientconfignetwork function could not determine a network from Wireguard confifuration file!\n' 1>&2
			return 1
		else
			if [ ${a6#*/} -lt $((a5 + 5)) ] && [ ${a6#*/} -gt $((a5 - 5)) ]; then
				printf 'clientconfignetwork function guessed a network close to existing network! Using existing network! Verify network in configuration file!\n' 1>&2
				printf "$a6"
			else
				printf 'clientconfignetwork function guessed a network! Verify network in configuration file!\n' 1>&2
				printf "$address"
			fi
		fi
	fi
}
HALP="

Edit variables in begining of script before running!

Usage:
$WGSCRIPTPATH <REQUIRED> <OPTION> <LIVE>

REQUIRED:
		- A hostname or username controlled by this script for this Wireguard interface name.
		  Creates a peer if 'new' OPTION specified. Provides details (config file) for hostname or username.

		- If Wireguard interface name provided script will stand up or restart the interface using existing configuration.

			OPTION:
	new		- Generate a new private and public key for specified hostname or username and display.

	remove	- Remove peer with specified hostname or username.

			LIVE:
	live	- If provided will update the Wireguard interface with new or removed peer information.
		  Configuration files are otherwise generated for next interface start.\n"
while GETARGS :L,i:p:P,G,D,E,--endpoint:--port:--iface:--network:--ip-beg:--ip-end:--lan:--isolate--isolate--route-add:,--route-rem:,--gateway:--dns-on--dns-off--dns: x "$@"; do
	OPTARG="${OPTARG// /}"
	case $x in
		-L)
			WGSUPDATE=true;;
		-i)
			! chkdnssyn "$OPTARG" ||  && errout "Invalid interface name!$HALP"
			! [ -f "$WGSCRIPTPATH$OPTARG.conf" ]
			IFACE="$OPTARG";;
		-p)
			! chkdnssyn "$OPTARG" && errout "Invalid peer (client) name ($OPTARG)!$HALP"
			[ -n "$WGC" ] && WGC+=", $OPTARG" || WGC="$OPTARG";;
		-P)
			SHOWALLWGC=true;;
		-G)
			WRITEWGS=true
			WRITEALLWGC=true;;
		-D)
			WRITEWGS=true
			DISABLE=true;;
		-E)
			WRITEWGS=true
			ENABLE=true;;
		--endpoint)
			ENDPOINT="$OPTARG"
			WRITEWGS=true
			WRITEALLWGC=true;;
		--port)
			! isport "$OPTARG" && errout "$HALP"
			PORT="$OPTARG"
			WRITEWGS=true
			WRITEALLWGC=true;;
		--iface)
			! chkdnssyn "$OPTARG" && errout "Invalid interface name!$HALP"
			NEW_IFACE="$OPTARG"
			WRITEWGS=true;;
		--network)
			! iscidr "$OPTARG" && errout "Invalid network!$HALP"
			! rangeunused "$OPTARG" && errout "Network range in use ($OPTARG)!$HALP"
			NTWRK="$OPTARG"
			WRITEWGS=true
			WRITEALLWGC=true;;
		--ip-beg)
			! isip "$OPTARG" && errout "Invalid peer (client) begining IP ($OPTARG)$HALP"
			NTWRK_BEG="$OPTARG"
			WRITEWGS=true
			CHECKALLWGC=true;;
		--ip-end)
			! isip "$OPTARG" && errout "Invalid peer (client) ending IP ($OPTARG)$HALP"
			NTWRK_END="$OPTARG"
			WRITEWGS=true
			CHECKALLWGC=true;;
		--lan)
			ifaceunused "$OPTARG" && errout "Cannot change LAN! Interface does not exist ($OPTARG)!$HALP"
			LAN="$OPTARG"
			WRITEWGS=true
			WRITEALLWGC=true;;
		--isolate)
			ISOLATE=false
			WRITEWGS=true
			WRITEALLWGC=true;;
		--unisolate)
			ISOLATE=true
			WRITEWGS=true
			WRITEALLWGC=true;;
		--network-add)
			WRITEALLWGC=true
			WRITEWGS=true
			! iscidr "$OPTARG" && errout "$OPTARG is not a valid CIDR address!"
			[ -n "$ADD_ROUTES" ] && ADD_ROUTES+=", $OPTARG" ||  ADD_ROUTES="$OPTARG";;
		--network-rem)
			WRITEALLWGC=true
			WRITEWGS=true
			if iscidr "$OPTARG"; then
				[ -n "$REM_ROUTES" ] && OPTARG=", $OPTARG"
				REM_ROUTES="$REM_ROUTES$OPTARG"
			else
				errout "$OPTARG is not a valid CIDR address!"
			fi
			echo 'remove network route from server and clients';;
		--gateway-on)
			WRITEALLWGC=true
			WRITEWGS=true
			GATEWAY=true
			echo 'force lan is gateway';;
		--gateway-off)
			WRITEALLWGC=true
			WRITEWGS=true
			GATEWAY=false
			echo 'lan is not gateway';;
		--dns-on)
			WRITEALLWGC=true
			WRITEWGS=true
			USE_DNS=true
			echo 'force peer dns server';;
		--dns-off)
			WRITEALLWGC=true
			WRITEWGS=true
			USE_DNS=false
			echo 'no peer dns server';;
		--dns)
			WRITEALLWGC=true
			WRITEWGS=true
			NEW_DNS_SRV="$OPTARG"
			echo 'peer dns server';;
		--mtu)
			CHECKALLWGC=true
			WRITEWGS=true
			NTWRK_MTU="$OPTARG"
			echo 'peer dns server';;
		:|*|?) errout "$HALP";;
	esac
done

#DETERMINE WIREGAURD INTERFACE NAME FROM SCRIPT NAME (wireguard_X), SCRIPT PATH, OR CREATES NEW DEFAULT WIREGAURD INTERFACE (wgX) WITH CONFIGURATION FILES
#VERIFY SCRIPT NAME
WGSCRIPTWRITE() {
	local x WGSCRIPTPATH_NEW WGSCRIPT_NEW
	WGSCRIPTPATH_NEW="/etc/wireguard/generatewg_$1"
	if [ ! -f "$WGSCRIPTPATH_NEW" ]; then
		WGSCRIPT_NEW=($(<$WGSCRIPTPATH$WGSCRIPTNAME))
		for x in "${!WGSCRIPT_NEW[@]}"; do
			[[ "${}" = "IFACE=''"* ]] && WGSCRIPT_NEW[$x]="IFACE='$1'" && break 1
		done
		printf -- "${WGSCRIPT_NEW[@]}" > "$WGSCRIPTPATH_NEW"
		chown root "$WGSCRIPTPATH_NEW"
		chmod 700 "$WGSCRIPTPATH_NEW"
		err "Script copied for use with $1!"
	fi
	err "Use $WGSCRIPTPATH_NEW instead! Script file can be moved."
}
if [ -z $IFACE ]; then
	if [ ! "$WGSCRIPTNAME" = 'generatewg_' ] && [[ "$WGSCRIPTNAME" == 'generatewg_'* ]]; then
		IFACE="${WGSCRIPTNAME#*_}"
	else
		for x in {0..255}; do
			if [ ! -d /sys/class/net/wg${x} ] && [ ! -f /etc/wireguard/wg${x}.conf ]; then
				WRITEWGS=true
				IFACE="wg$x"
				err "Script IFACE interface variable not set!\nScript name has no hint!\nIFACE set to $IFACE!"
				WGSCRIPTWRITE "$IFACE"
				break 1
			fi
		done
	fi
elif [ ! "$WGSCRIPTNAME" = "generatewg_$IFACE" ]; then
	err "Script name is improper!"
	WGSCRIPTWRITE "$IFACE"
fi

#PARSE CONFIG FILE [Interface] SECTION
WGSFULLPATH="/etc/wireguard/$IFACE.conf"
if [ -f "$WGSFULLPATH" ]; then
	WGCONFIG=($(<$WGSFULLPATH))
	for x in "${!WGCONFIG[@]}"; do
		case "${WGCONFIG[$x]}" in
\#generatewg_version = *)
	VERSION="${WGCONFIG[$x]#* = }"
	[ "$VERSION" != '1' ] && errout "$WGSFULLPATH configuration file is from script version $VERSION!\nCannot continue with $WGSCRIPTPATH/$WGSCRIPTNAME version 1!";;
PrivateKey = *) PRIKEY="${WGCONFIG[$x]#* = }";;
ListenPort = *) CUR_PORT="${WGCONFIG[$x]#* = }";;
\#PresharedKey) CUR_USEPREKEY=true;;
\#lan = *) CUR_LAN="${WGCONFIG[$x]#* = }";;
\#gateway) CUR_GATEWAY=true;;
\#isolate) CUR_ISOLATE=true;;
\#routes = *) CUR_ROUTES="${WGCONFIG[$x]#* = }";;
\#beg = *) CUR_NTWRK_BEG="${WGCONFIG[$x]#* = }";;
			\#end = *) CUR_NTWRK_END="${WGCONFIG[$x]#* = }";;
			\#Endpoint = *) CUR_ENDPOINT="${WGCONFIG[$x]#* = }";;
			\#PersistentKeepalive = *) CUR_KEEPALIVE="${WGCONFIG[$x]#* = }";;
Address = *) CUR_NTWRK="${WGCONFIG[$x]#* = }";;
			\#DNS = *) CUR_DNS_SRV="${WGCONFIG[$x]}";;
			\#use_dns) CUR_USE_DNS=true;;
			MTU = *) CUR_NTWRK_MTU="${WGCONFIG[$x]#* = }";;
			\#PreUp = *) CUR_PREUP="${WGCONFIG[$x]#* = }";;
			\#PostUp = *) CUR_POSTUP="${WGCONFIG[$x]#* = }";;
			\#PreDown = *) CUR_PREDOWN="${WGCONFIG[$x]#* = }";;
			\#PostDown = *) CUR_POSTDOWN="${WGCONFIG[$x]#* = }";;
*\[Peer]*) unset WGCONFIG[$x] && break 1;;
		esac
		unset WGCONFIG[$x]
	do
else
	WRITEWGS=true
fi

#INPUT SANTIZATIONS
#VERIFY ENDPOINT PORT
[ -n "$CUR_PORT" ]  && ! [[ $CUR_PORT =~ ^[0-9]+$ ]] || [ $CUR_PORT -lt 1 ] || [ $CUR_PORT -gt 65535 ] && errout "Invalid endpoint port from configuration file ($CUR_PORT)!"
if [ -n "$PORT" ]; then
	[[ ! $PORT =~ ^[0-9]+$ ]] || [ $PORT -lt 1 ] || [ $PORT -gt 65535 ] || lsof -i -P -n|grep LISTEN|grep -q "$PORT" && errout "Invalid endpoint port from script or user ($PORT)!"
	if [ -n "$CUR_PORT" ] && [ $CUR_PORT -ne $PORT ]; then
		err "Changing endpoint port from $CUR_PORT to $PORT!\nAll clients will have configuration files generated, and will require these configuration files once changes are live!"
		unset CUR_PORT
		WRITEWGS=true
		WRITEALLWGC=true
	fi
elif [ -n "$CUR_PORT" ]; then
	PORT=$CUR_PORT
	unset CUR_PORT
else
	PORT="51820"
	while lsof -i -P -n|grep LISTEN|grep -q "$PORT"; do
		PORT=$((PORT + 1))
	done
	WRITEWGS=true
	WRITEALLWGC=true
fi
#VERIFY WIREGUARD SERVER LAN TO USE
[ -n "$CUR_LAN" ] && ! ifaceunused "$CUR_LAN" && errout "Invalid endpoint LAN interface from configuration file ($CUR_LAN)!"
if [ -n "$LAN" ]; then
	! ifaceunused "$LAN" && errout "Invalid endpoint LAN interface from script or user ($LAN)!"
	if [ -n "$CUR_LAN" ] && [ "$CUR_LAN" != "$LAN" ]; then
		err "Changing endpoint interface network from $CUR_LAN to $LAN!\nClients may need configuration files generated, and will require these configuration files once changes are live!"
		unset CUR_NTWRK
		WRITEWGS=true
		CHECKALLWGC=true
	fi
elif [ -n "$CUR_LAN" ]; then
	LAN="$CUR_LAN"
	unset CUR_LAN
else
	LAN=$(ip route show default)
	LAN=${LAN#* dev }
	LAN=${LAN%% *}
	if GATEWAY || ! ISOLATE; then
		err "Using endpoint LAN interface $LAN network ($(getcidrof $LAN))!"
		CHECKALLWGC=true
	fi
	WRITEWGS=true
fi
NTWRK_LAN="$(networkmin $LAN)/${LAN#*/}"
#VERIFY WIREGAURD SERVER INTERFACE IP AND NETWORK
if [ -n "$CUR_NTWRK" ]; then
	! iscidr "$CUR_NTWRK" && errout "Invalid endpoint interface CIDR address from configuration file ($CUR_NTWRK)!"
	[ "$(networkmin $CUR_NTWRK)" = "${CUR_NTWRK#*/}" ] || [ "$(networkmax $CUR_NTWRK)" = "${CUR_NTWRK#*/}" ] && errout "Endpoint interface from configuration file is network/broadcast, not an address ($CUR_NTWRK)!"
fi
if [ -n "$NTWRK" ]; then
	! iscidr "$NTWRK" && errout "Invalid endpoint interface CIDR address from script or user ($NTWRK)!"
	[ "$(networkmin $NTWRK)" = "${NTWRK#*/}" ] || [ "$(networkmax $NTWRK)" = "${NTWRK#*/}" ] && errout "Endpoint interface from script or user is network/broadcast, not an address (got '$NTWRK', try '$(getnexthost $NTWRK)'?)!"
	! rangeunused "$NTWRK" && errout "$NTWRK is in use!"
	if [ -n "$CUR_NTWRK" ] && [ "$CUR_NTWRK" != "$NTWRK" ]; then
		err "Changing endpoint interface network from $CUR_NTWRK to $NTWRK!\nClients may need configuration files generated, and will require these configuration files once changes are live!"
		unset CUR_NTWRK
		WRITEWGS=true
		CHECKALLWGC=true
	fi
elif [ -n "$CUR_NTWRK" ]; then
	NTWRK="$CUR_NTWRK"
	unset CUR_NTWRK
else
	[ ${#WGCONFIG[@]} -ne 0 ] && NTWRK=$(clientconfignetwork "$IFACE")
	[ -z "$NTWRK" ] && NTWRK="$(generatenetworkfrom $LAN)" && NTWRK="$(getnexthost $NTWRK)/${NTWRK#*/}"
	err "Using $NTWRK for $IFACE interface!"
	WRITEWGS=true
	CHECKALLWGC=true
fi
NTWRK_NTWRK="$(networkmin $NTWRK)/${NTWRK#*/}"
#VERIFY IF PEERS SHOULD USE PRESHARED KEY
[ -z "$CUR_USEPREKEY" ] && CUR_USEPREKEY=false
if [ -n "$USEPREKEY" ]; then
	! torf "$USEPREKEY" && errout "USEPREKEY variable not true or false from script!"
	if [ -n "$CUR_USEPREKEY" ] && [ $CUR_USEPREKEY != $USEPREKEY ]; then
		if $USEPREKEY; then
			err "The server now requires clients use a preshared key!\nAll existing clients not already using a key will have keys generated.\nClients must update their configuration once live!"
		else
			err "The server will not require clients use a preshared key!\nExisting clients will have no preshared key after next key generation unless specific clients have this requirement!"
		fi
		unset CUR_USEPREKEY
		WRITEWGS=true
		CHECKALLWGC=true
	fi
else
	USEPREKEY=$CUR_USEPREKEY
	unset CUR_USEPREKEY
fi
#VERIFY ADDITIONAL ROUTES TO FORWARD FOR ALL CLIENTS
[ -n "$CUR_ROUTES" ] && ! ismulticidr "$CUR_ROUTES" && errout "Routes are incorrect from configuration file ($CUR_ROUTES)!"
if [ -n "$ROUTES" ]; then
	! ismulticidr "$ROUTES" && errout "$ROUTES routes are incorrect from script!"
	if [ -n "$CUR_ROUTES" ] && [ "$CUR_ROUTES" != "$ROUTES" ]; then
		err "Changing additional client routes from:\n$CUR_ROUTES\nto:\n$ROUTES\nClients with different routes will have configuration files generated, and will require these configuration files once changes are live!"
		unset CUR_ROUTES
		WRITEWGS=true
		CHECKALLWGC=true
	fi
elif [ -n "$CUR_ROUTES" ]; then
	NTWRK="$CUR_ROUTES"
	unset CUR_ROUTES
else
	ROUTES=''
fi
if [ -n "$ADD_ROUTES" ]; then
	err "Attempting addition to all client routes from:\n$ROUTES\nto:"
	while [ -n "$ADD_ROUTES" ]; do
		x="${ADD_ROUTES%%, *}"
		! iscidr "$x" || [ "$x" != "$(networkmin $x)/${x#*/}" ] && errout "$x route is not a CIDR network from user (Should be $(networkmin $x)/${x#*/}?)!"
		ADD_ROUTES="${ADD_ROUTES#*, }"
		if [ -n "$ROUTES" ]; then
			if [[ "$ROUTES" = *"$x"* ]]; then
				err "Route $x can not be added as it is already an existing route!"
			else
				ROUTES="$ROUTES, $x"
				WRITEWGS=true
				CHECKALLWGC=true
			fi
		else
			ROUTES="$x"
			WRITEWGS=true
			CHECKALLWGC=true
		fi
	done
	err "$ROUTES\nClients with different routes will have configuration files generated, and will require these configuration files once changes are live!"
fi
if [ -n "$REM_ROUTES" ]; then
	if [ -z "$ROUTES" ]; then
		errout "Can not remove routes as none exist ($REM_ROUTES)!"
	else
		err "Attempting removal of all client routes from:\n$ROUTES\nto:"
		while [ -n "$REM_ROUTES" ]; do
			x="${REM_ROUTES%%, *}"
			! iscidr "$x" || [ "$x" != "$(networkmin $x)/${x#*/}" ] && errout "$x route is not a CIDR network from user (Should be $(networkmin $x)/${x#*/}?)!"
			REM_ROUTES="${REM_ROUTES#*, }"
			if [[ "$ROUTES" = *"$x"* ]]; then
				ROUTES="${ROUTES//$x}"
				ROUTES="${ROUTES//, , /, }"
				[[ "$ROUTES" = ', '* ]] && ROUTES="${ROUTES#, *}"
				[[ "$ROUTES" = *', ' ]] && ROUTES="${ROUTES%*, }"
				WRITEWGS=true
				CHECKALLWGC=true
			else
				err "Route $x can not be removed as it is not currently routed!"
			fi
		done
		err "$ROUTES\nClients with different routes will have configuration files generated, and will require these configuration files once changes are live!"
	fi
fi
#VERIFY IF PEERS SHOULD FORWARD "ALL" TRAFFIC TO ENDPOINT
[ -z "$CUR_GATEWAY" ] && CUR_GATEWAY=false
if [ -n "$GATEWAY" ]; then
	! torf "$GATEWAY" && errout "GATEWAY variable not true or false from script!"
	if [ $CUR_GATEWAY != $GATEWAY ]; then
		$GATEWAY && err 'Enabling endpoint to forward all traffic "internet gateway"!' || err 'Disabling endpoint to forward all traffic "internet gateway"!'
		err "All clients will have configuration files generated!\nAll clients must update to this new configuration once live!"
		unset CUR_GATEWAY
		WRITEWGS=true
		WRITEALLWGC=true
	fi
else
	GATEWAY=$CUR_GATEWAY
	unset CUR_GATEWAY
fi
#VERIFY IF PEERS SHOULD FORWARD ONLY VPN NETWORK
[ -z "$CUR_ISOLATE" ] && CUR_ISOLATE=false
if [ -n "$ISOLATE" ]; then
	! torf "$ISOLATE" && errout "ISOLATE variable not true or false from script!"
	if [ $CUR_ISOLATE != $ISOLATE ]; then
		if ! $GATEWAY; then
			if $ISOLATE; then
				err "Isolating clients and $IFACE interface traffic to reach only $NTWRK_NTWRK network!"
			else
				err "Adding routing from endpoint interface $IFACE network $NTWRK_NTWRK to:\nLAN interface ($LAN) network: $NTWRK_LAN\nAdditional interface routes: $ROUTES\nAdditional client routes (check clients below)!"
			fi
			err "Clients may need configuration files generated, and will require these configuration files once changes are live!"
			CHECKALLWGC=true
		fi
		unset CUR_ISOLATE
		WRITEWGS=true
	fi
else
	ISOLATE=$CUR_ISOLATE
	unset ISOLATE
fi
#VERIFY SPECIFIED PEER BEGINING AND END IP RANGE
[ -n "$CUR_NTWRK_BEG" ] && ! isip "$CUR_NTWRK_BEG" || ! inrange "$CUR_NTWRK_BEG" "$NTWRK_NTWRK" && errout "Invalid client range begin IP from configuration file ($CUR_NTWRK_BEG)!"
if [ -n "$NTWRK_BEG" ]; then
	! isip "$NTWRK_BEG" || ! inrange "$NTWRK_BEG" "$NTWRK_NTWRK" && errout "Invalid client range begin IP from script or user ($NTWRK_BEG)!"
	if [ -n "$CUR_NTWRK_BEG" ] && [ "$CUR_NTWRK_BEG" != "$NTWRK_BEG" ]; then
		err "Client network range begin changed to $NTWRK_BEG from $CUR_NTWRK_BEG!\nClients may need configuration files generated, and will require these configuration files once changes are live!"
		unset CUR_NTWRK_BEG
		WRITEWGS=true
		CHECKALLWGC=true
	fi
elif [ -n "$CUR_NTWRK_BEG" ]; then
	NTWRK_BEG="$CUR_NTWRK_BEG"
	unset CUR_NTWRK_BEG
else
	NTWRK_BEG=$(getnexthost "$NTWRK")
	CHECKALLWGC=true
	WRITEWGS=true
fi
[ -n "$CUR_NTWRK_END" ] && ! isip "$CUR_NTWRK_END" || ! inrange "$CUR_NTWRK_END" "$NTWRK_NTWRK" && errout "Invalid client range begin IP from configuration file ($CUR_NTWRK_END)!"
if [ -n "$NTWRK_END" ]; then
	! isip "$NTWRK_END" || ! inrange "$NTWRK_END" "$NTWRK_NTWRK" && errout "Invalid client range begin IP from script or user ($NTWRK_END)!"
	if [ -n "$CUR_NTWRK_END" ] && [ "$CUR_NTWRK_END" != "$NTWRK_END" ]; then
		err "Client network range begin changed to $NTWRK_END from $CUR_NTWRK_END!\nClients may need configuration files generated, and will require these configuration files once changes are live!"
		unset CUR_NTWRK_END
		WRITEWGS=true
		CHECKALLWGC=true
	fi
elif [ -n "$CUR_NTWRK_BEG" ]; then
	NTWRK_BEG="$CUR_NTWRK_BEG"
	unset CUR_NTWRK_BEG
else
	NTWRK_BEG=$(getpriorhost "$NTWRK")
	CHECKALLWGC=true
	WRITEWGS=true
fi
#VERIFY WIREGUARD ENDPOINT FOR PEERS
if [ -n "$CUR_ENDPOINT" ]; then
	if [ -z "$ENDPOINT" ]; then
		isip "$CUR_ENDPOINT" && [ -z "$ENDPOINT_IP" ] && ENDPOINT_IP="$(dig +short myip.opendns.com @resolver1.opendns.com)"
		[ -n "$ENDPOINT_IP" ] && [ "$ENDPOINT_IP" != "$CUR_ENDPOINT" ] && err "Detected WAN IP has changed from $CUR_ENDPOINT to $ENDPOINT_IP!\nIf accurate all clients require new configuration files be generated with updated IP!\nRerun script as such to resolve:\n$WGSFULLPATH/$WGSCRIPTNAME --endpoint"
		ENDPOINT="$CUR_ENDPOINT"
		unset CUR_ENDPOINT
	fi
fi
if [ -n "$ENDPOINT" ]; then
	isip "$ENDPOINT" && [ -z "$ENDPOINT_IP" ] && ENDPOINT_IP="$(dig +short myip.opendns.com @resolver1.opendns.com)"
	[ -n "$ENDPOINT_IP" ] && [ "$ENDPOINT_IP" != "$ENDPOINT" ] && err "Detected WAN IP of $ENDPOINT_IP does not match requested $ENDPOINT!\nRerun script as such to resolve:\n$WGSFULLPATH/$WGSCRIPTNAME --endpoint"
	if [ -n "$CUR_ENDPOINT" ] && [ "$CUR_LAN" != "$ENDPOINT" ]; then
		err "Changing endpoint from $CUR_ENDPOINT to $ENDPOINT!\nAll clients require new configuration files be generated, and will require these configuration files once changes are live!"
		unset CUR_ENDPOINT
		WRITEWGS=true
		WRITEALLWGC=true
	fi
else
	[ -z "$ENDPOINT_IP" ] && ENDPOINT="$(dig +short myip.opendns.com @resolver1.opendns.com)"
	[ -z "$ENDPOINT" ] || ! isip "$ENDPOINT" && errout "No endpoint specified! Could not determine WAN IP!\nRerun script as such with known good information to resolve:\n$WGSFULLPATH/$WGSCRIPTNAME ${@} --endpoint <HOSTNAME/IP>"
	err "No endpoint specified! Detected WAN IP of $ENDPOINT to use as endpoint for clients!"
	WRITEWGS=true
	WRITEALLWGC=true
fi
#VERIFY DNS SERVER AND CLIENT DNS SERSVER SETTINGS
if [ -n "$NEW_DNS_SRV" ]; then
	if [ -z "$DNS_SRV" ] || [ "$DNS_SRV" != "$NEW_DNS_SRV" ] || [ -n "$CUR_DNS_SRV" ] && [ "$CUR_DNS_SRV" != "$NEW_DNS_SRV" ]; then
		validdns "$NEW_DNS_SRV" || err "Invalid/unreachable DNS from user ($NEW_DNS_SRV)!"
		[ -z "$NEW_DNS_SRV" ] && err "Removing DNS!" || err "Changing DNS from $CUR_DNS_SRV to $NEW_DNS_SRV!"
		err "Clients may need configuration files generated, and will require these configuration files once changes are live!"
		DNS_SRV="$NEW_DNS_SRV"
		unset NEW_DNS_SRV
		WRITEWGS=true
		CHECKALLWGC=true
	fi
	unset CUR_DNS_SRV
elif [ -n "$DNS_SRV" ]; then
	if [ -n "$CUR_DNS_SRV" ]; then
		if [ "$CUR_DNS_SRV" != "$DNS_SRV" ]; then
			validdns "$DNS_SRV" || err "Invalid/unreachable DNS from script ($DNS_SRV)!"
			[ -z "$DNS_SRV" ] && err "Removing DNS!" || err "Changing DNS from $CUR_DNS_SRV to $DNS_SRV!"
			err "Clients may need configuration files generated, and will require these configuration files once changes are live!"
			DNS_SRV="$CUR_DNS_SRV"
			WRITEWGS=true
			CHECKALLWGC=true
		fi
		unset CUR_DNS_SRV
	fi
elif [ -n "$CUR_DNS_SRV" ]; then
	validdns "$CUR_DNS_SRV" || err "Invalid/unreachable stored DNS in configuration file ($CUR_DNS_SRV)!"
	DNS_SRV="$CUR_DNS_SRV"
	unset CUR_DNS_SRV
fi
if [ -n "$USE_DNS" ]; then
	torf "$USE_DNS" || errout "USE_DNS variable not true or false from script!"
	if [ $CUR_USE_DNS != $USE_DNS ]; then
		$USE_DNS && err "Clients now set to use DNS server of $DNS_SRV!" || err "Client DNS server no longer enforced!"
		err "Clients may need configuration files generated, and will require these configuration files once changes are live!"
		unset CUR_USE_DNS
		WRITEWGS=true
		CHECKALLWGC=true
	fi
	$USE_DNS && validdns "$DNS_SRV" || errout "Current DNS server $DNS_SRV is not valid!"
else
	USE_DNS=$CUR_USE_DNS
	unset USE_DNS
fi




[ -n "$MTU" ] && [ $MTU -eq 0 ] && unset MTU
if [ -n "$DNS_SRV" ]; then
	! isip "$DNS_SRV" && errout "Invalid DNS IP!"
	

#PARSE CONFIG FILE [peer] SECTION(S)
if [ -n "$WGC" ] || SHOWALLWGC || CHECKALLWGC || WRITEALLWGC && [ ${#WGCONFIG[@]} -ne 0 ]; then
	y=-1
	for x in "${!WGCONFIG[@]}"; do
		! SHOWALLWGC && ! CHECKALLWGC && ! WRITEALLWGC && [ -z "$WGC" ] && break 1
		case "${WGCONFIG[$x]}" in
			*\[Peer]*)
				if [ -z "${PEERS[$y]}" ]; then
					#get information
					err "Client in configuration file is not saved correctly!\nAssociated information which is being removed:\n${PEERS[$y]}"
				else
					if SHOWALLWGC || CHECKALLWGC || WRITEALLWGC || [ $y -eq -1 ]; then
						y=$((y + 1))
					elif [ -n "$WGC" ] && [[ "$WGC" = *"${PEERS[$y]}"* ]]; then
						WGC="${WGC/${PEERS[$y]}/}"
						WGC="${WGC//, , /, }"
						[[ "$WGC" = ', '* ]] && WGC="${WGC#, *}"
						[[ "$WGC" = *', ' ]] && WGC="${WGC%*, }"
						[ -z "$WGC" ] && break 1 || y=$((y + 1))
					fi
					[ '#' = "${WGCONFIG[$x]::1}" ] && PEERSSTATUSES[$y]='#' || PEERSSTATUSES[$y]=''
				fi;;
			\#peer = *) PEERS[$y]="${WGCONFIG[$x]#\#peer = }";;
			*PublicKey = *) [ -n "${PEERS[$y]}" ] && PEERSPUBKEYS[$y]="${WGCONFIG[$x]#* = }" && [ -z "${PEERSPUBKEYS[$y]}" ] && peererr "$y";;
			\#prekey = *) [ -n "${PEERS[$y]}" ] && PEERSPREKEYS[$y]="${WGCONFIG[$x]#* = }";;
			*PresharedKey = *) [ -n "${PEERS[$y]}" ] && PEERSPREKEYS[$y]="${WGCONFIG[$x]#* = }";;
			*AllowedIPs = *) [ -n "${PEERS[$y]}" ] && PEERSIPS[$y]="${WGCONFIG[$x]#* = }" && PEERSIPS[$y]="${PEERSIPS[$y]%%,*}";;
			*PersistentKeepalive = *) [ -n "${PEERS[$y]}" ] && PEERSALIVES[$y]="${WGCONFIG[$x]#* = }";;
			\#DNS = *) [ -n "${PEERS[$y]}" ] && PEERSDNSS[$y]="${WGCONFIG[$x]#* = }";;
			\#MTU = *) [ -n "${PEERS[$y]}" ] && PEERSMTUS[$y]="${WGCONFIG[$x]#* = }";;
		esac
	done
fi

#LOAD WIREGAURD INTERFACE CONFIGURATION FILE TO MEMORY AND SET VARIABLES OR CREATE FILE
#VERIFY CONFIGURATION FILE CONTINUITY AGAINST SCRIPT SETTINGS, IF DIFFERENT AND CHANGES ACCEPTED BY USER MODIFIES CONFIGURATION FILE TO MATCH SCRIPT


[ "$IFACE" =  "$(defaultinterface)" ]; then
	echo 1>/proc/sys/net/ipv4/ip_forward
	iptables -A INPUT -i LAN-LAN -s 10.9.0.0/24 -j ACCEPT
	iptables -A INPUT -i VPN2 -s 10.10.0.0/24 -j ACCEPT
	iptables -A OUTPUT -o LAN-LAN -s 10.10.0.0/24 -d 10.9.0.0/24 -j ACCEPT
	iptables -A OUTPUT -o VPN2 -s 10.9.0.0/24 -d 10.10.0.0/24 -j ACCEPT
	iptables -A FORWARD -i LAN-LAN -o VPN2 -j ACCEPT
	iptables -A FORWARD -i VPN2 -o LAN-LAN -j ACCEPT
fi

#VERIFY ENDPOINT KEYS
if [ -z $WGS_PRIKEY ]; then
	WRITEWGS=true
	printf "No Wireguard interface private key! Generating new key!" 1>&2
	WGS_PRIKEY=$(wg genkey)
fi
WGS_PUBKEY=$(wg pubkey<<<"$WGS_PRIKEY")


if [ "${WGC}" = "${IFACE}" ]
	then
		if [ -d /sys/class/net/${IFACE} ]
			then
				ip link delete dev ${IFACE}
			fi
		ip link add dev ${IFACE} type wireguard && wg setconf ${IFACE} ${WGSPATH} && exit
		exit 1
	fi
if [ "${2}" = "remove" ]
	then
		if [ -d ${WGCDIR} ]
			then
				printf "${WGC} removed!\n"
				rm -rf ${WGCDIR}
			else
				printf "No Hostname or Username called ${WGC} exists!\n"
			fi
		rm -f ${WGSPATH}
		WGSPATHCREATE
		WGSLIVE ${2} ${3}
	else
		if [ ! -d ${WGCDIR} ]
			then
				mkdir -p ${WGCDIR}
			fi
		if [ -f ${WGCDIR}address ]
			then
				ADDRESS=$(<"${WGCDIR}address")
			else
				ADDRESS=$(echo $NTWRK|cut -d'.' -f1)'.'$(echo $NTWRK|cut -d'.' -f2)'.'$(echo $NTWRK|cut -d'.' -f3)'.'
				WGSFILE=$(<${WGSPATH})
				while echo "${WGSFILE}"|grep -q "${ADDRESS}${NTWRK_BEG}"
					do
						if [ $NTWRK_BEG -eq $NTWRK_END ]
							then
								printf "No available address!\n"
								exit 1
							else
								((NTWRK_BEG=NTWRK_BEG+1))
							fi
				done
				ADDRESS="${ADDRESS}${NTWRK_BEG}"
				printf "${ADDRESS}" > ${WGCDIR}address
				if [ -f ${WGC} ]
					then
						rm -f ${WGC}publickey
					fi
			fi
		if [ ! -f ${WGCDIR}privatekey ] || [ "${2}" = "new" ]
			then
				PRIVKEY=$(wg genkey)
		    		printf "${PRIVKEY}" > ${WGCDIR}privatekey
				if [ -f ${WGCDIR}publickey ]
					then
						rm -f ${WGCDIR}publickey
					fi
				if [ -f ${WGC} ]
					then
						rm -f ${WGC}publickey
					fi
			else
				PRIVKEY=$(<"${WGCDIR}privatekey")
			fi
		if [ ! -f ${WGCDIR}publickey ] || [ "${2}" = "new" ]
			then
				PUBLKEY=$(printf "${PRIVKEY}" | wg pubkey)
				printf "${PUBLKEY}" > ${WGCDIR}publickey
				if [ -f ${WGC} ]
					then
						rm -f ${WGC}publickey
					fi
			else
				PUBLKEY=$(<"${WGCDIR}publickey")
			fi
		if [ ! -f ${WGC} ] || [ "${2}" = "new" ]
			then
				WGCFILE="[Interface]\n\
PrivateKey = $PRIVKEY\n\
PublicKey = $PUBLKEY\n\
Address = $ADDRESS/$(echo $NTWRK|cut -d'/' -f2)\n\
\n\
[Peer]\n\
PublicKey = $SPUBLKEY\n\
AllowedIPs = $NTWRK\n\
Endpoint = $ENDPOINT:$PORT"
				printf "${WGCFILE}" > ${WGC}
			else
				WGCFILE=$(<"${WGC}")
			fi
		if grep -q "$ADDRESS" ${WGSPATH} && [ "${2}" = "new" ]
			then
				rm -f ${WGSPATH}
				WGSPATHCREATE
		elif ! grep -q "$ADDRESS" ${WGSPATH}
			then
				printf "\n\
\n\
[Peer]\n\
PublicKey = $PUBLKEY\n\
AllowedIPs = $ADDRESS/32" >> ${WGSPATH}
			fi
		WGSLIVE ${2} ${3}
		printf "${WGCFILE}\n"
	fi
exit



WGSPATHCREATE() {

	WGSFILE="[Interface]\n\
PrivateKey = ${SPRIVKEY}\n\
PublicKey = ${SPUBLKEY}\n\
ListenPort = ${PORT}"
	if [ -d ${WGSDIR} ]
		then
			for x in $(find ${WGSDIR} -maxdepth 1 -mindepth 1 -type d)
				do
					if [ -f ${x}/publickey ] && [ -f ${x}/address ]
						then
							WGSFILE="$WGSFILE\n\
\n\
[Peer]\n\
PublicKey = $(<${x}/publickey)\n\
AllowedIPs = $(<${x}/address)/32"
						fi
				done
		else
			mkdir -p ${WGSDIR}
		fi
	if [ ! -z $WGSCRIPTPATH_NEW ]
		then
			if [ ! -f ${WGSCRIPTPATH_NEW} ]
				then
					printf "Script moved to: ${WGSCRIPTPATH_NEW}\n"
					cp ${WGSCRIPTPATH} ${WGSCRIPTPATH_NEW}
				fi
			sed -i -e "0,/.*ENDPOINT=.*/ s/.*ENDPOINT=.*/ENDPOINT='${ENDPOINT}'/" ${WGSCRIPTPATH_NEW}
			sed -i -e "0,/.*IFACE=.*/ s/.*IFACE=.*/IFACE='${IFACE}'/" ${WGSCRIPTPATH_NEW}
		fi
	printf "${WGSFILE}" > ${WGSPATH}
}
WGSLIVE () {
	if [ "${2}" = "live" ] || ([ "${1}" = "live" ] && [ -z $3 ])
		then
			if [ -d /sys/class/net/${IFACE} ]
				then
					wg syncconf ${IFACE} ${WGSPATH}
				else
					if [ -z $WGSCRIPTPATH_NEW ]
						then
							printf "Interface ${IFACE} not running!\n\
Start interface with:\n\
${WGSCRIPTPATH} ${IFACE}\n"
						else
							printf "Interface ${IFACE} not running!\n\
Start interface with:\n\
${WGSCRIPTPATH_NEW} ${IFACE}\n"
						fi
				fi
		fi
}

#!/bin/bash

#hostname or IP that peers ("clients") connect to, save yourself trouble and utilize a DNS name
#if blank attempts to determine WAN IP, if a WAN IP (or blank) and actual IP changes all peers ("clients") must be updated!
ENDPOINT=''
#port that peers ("clients") connect to, recommend changing from default (consult list of ports, Wiki?)
#if blank uses default port of 51820, ascends if used
PORT=''
#disconnect peers ("clients") and endpoint from LAN when true instead of false
#overriden by GATEWAY=true, if peer ("client") network conflict traffic is mostly routed to endpoint
ISOLATE=false
#peers ("clients") pass "all" traffic to endpoint's LAN route when true instead of false
#when true absolutely consider setting USE_DNS to true and selecting a "safe" DNS server for DNS_SRV!
GATEWAY=false

#######################################################
########## ADVANCED AND/OR OPTIONAL FEATURES ##########
#######################################################

#WireGuard interface this script controls
#if blank uses default of wg0 - wg255, ascends if used
#if blank and script doesn't contain interface name a new interface and script file will be generated (generatewg_$IFACE)
IFACE=''
#IP and network of the local Wireguard interface, CIDR format only: X.X.X.X/X
#if blank checks LAN for network, ascends networks if used
NTWRK=''
#peer ip range, CIDR format only: X.X.X.X/X
#if blank ascends from NTWRK, wraps, and ends at NTWRK_END or NTWRK
NTWRK_BEG=''
NTWRK_END=''
#attach VPN to this "LAN" interface name
#if blank uses system default network (network usually includes a NAT to the internet, routable only if GATEWAY=true)
LAN=''
#comma+space seperated list of CIDR LAN networks ('X.X.X.X/X, Y.Y.Y.Y/Y, Z.Z.Z.Z/Z') to attach VPN to
#peers ("clients") will route to and from these networks over endpoint in addition to NTWRK and LAN
ROUTES=''
#peers ("clients") will use DNS_SRV for DNS server(s) when true instead of false
USE_DNS=false
#if blank uses enpoint system's DNS server (USE_DNS must be true)
DNS_SRV=''
#base64 symmetric-key crypto is mixed with public key crypto for post-quantum resistance when true instead of false
#if false may lower CPU usage, perhaps a tiny boost in latency/speed as a result
USEPREKEY=true
#1-65535 seconds between empty encrypted packet sends by peers ("clients")
#if blank or 0 this is disabled
KEEPALIVE=300

NTWRK_MTU=''

PREUP=''

POSTUP=''

PREDOWN=''

POSTDOWN=''

########################################################################################
########## DO NOT EDIT BELOW SCRIPT UNLESS YOU KNOW WHAT YOU ARE DOING, KTHNX ##########
########################################################################################

err() {
	[ -n "$1" ] && printf -- "$1\n" 1>&2 && return 0
	return 1
}
errout() {
	err "$1"
	exit 1
}

#VERIFY EXISTANCE OF REQUIRED BINARIES/APPLICATIONS
BINARIES=('wg' 'ip')
for x in "${!BINARIES[@]}"; do
	BINARIES[$x]="$(command -v ${BINARIES[$x]})" || errout "Required binaries (applications) not available!"
done

#SET DEFAULTS FOR SCRIPT RUN
WRITEWGS=false
WGSUPDATE=false
WGCSTATUS='#'
WRITEWGC=false
SHOWALLWGC=false
CHECKALLWGC=false
WRITEALLWGC=false
isip() {
	[ -z "$1" ] || [[ ! $1 =~ ^[0-9/.]+$ ]] && err "$1 is not a valid IP address!" && return 1
	local a1 a2 a3 a4 v
	a4="$1"
	a1=${a4//.}
	[ $((${#a4} - ${#a1})) -ne 3 ] && return 1
	for y in {1..4}; do
		declare a$y="${a4%.*}"
		v="a$y"
		[ -z "${!v}" ] || [ ${!v} -gt 255 ] && err "$1 is not a valid IP address!" && return 1
		a4="${a4#*.}"
	done
	return 0
}
ismultiip() {
	local x y
	x="$1"
	while [ -n "$x" ]; do
		y="${x%%, *}"
		! isip "$y" && return 1
		x="${x#$y, }"
	done
	return 0
}
isprivateip() {
	[ -z "$1" ] || ! isip "$1" && return 1
	#check if IP is in private ranges
	return 0
}
iscidr() {
	[ -z "$1" ] || [[ ! $1 =~ ^[0-9/./\/]+$ ]] || ! isip "${1%/*}" && err "$1 is not a valid CIDR address!" && return 1
	local m1
	m1="${1#*/}"
	[ -z "$m1" ] || [[ "$m1" = *'.'* ]] || [[ "$m1" = *'/'* ]] || [ $m1 -gt 32 ] && err "$1 is not a valid CIDR address!" && return 1
	return 0
}
ismulticidr() {
	local x y
	x="$1"
	while [ -n "$x" ]; do
		y="${x%%, *}"
		! iscidr "$y" && return 1
		x="${x#$y, }"
	done
	return 0
}
GETARGS() {
	#present function call with getopts like interface
	local FLGVARNAME ARGVARNAME CURARG
	FLGVARNAME="FLG$$"
	ARGVARNAME="ARG$$"
	if [ -n "${!FLGVARNAME}" ]; then
		eval "${!FLGVARNAME}"
		eval "${!ARGVARNAME}"
	fi
	if declare -p FLG&>/dev/null; then
		if [ "${#FLG[@]}" -eq 0 ]; then
			unset $FLGVARNAME $ARGVARNAME $2 OPTARG
			return 1
		else
			for CURARG in "${!FLG[@]}"; do
				if [ $CURARG -eq 0 ]; then
					eval export "$2"="${FLG[0]}"
				else
					FLG[$((CURARG - 1))]="${FLG[$CURARG]}"
				fi
				unset FLG[$CURARG]
			done
			if [ ${#ARG[@]} -eq 0 ]; then
				unset OPTARG
			else
				[ -z "${ARG[0]}" ] && unset OPTARG
				for CURARG in "${!ARG[@]}"; do
					if [ $CURARG -eq 0 ]; then
						[ -n "${ARG[0]}" ] && export OPTARG="${ARG[0]}"
					else
						ARG[$((CURARG - 1))]="${ARG[$CURARG]}"
					fi
					unset ARG[$CURARG]
				done
			fi
			CURARG='$(declare -p FLG)'
			eval $FLGVARNAME="$CURARG"
			CURARG='$(declare -p ARG)'
			eval $ARGVARNAME="$CURARG"
			return 0
		fi
	fi
	local ALLFLGS SHRTFLGS TMPSHRTFLGS TMPLNGFLGS CURFLG TMP1 TMP2 REQARGS NOREQARGS ERRHNDL
	#input sanitize, build lists of accepted flags, then build array based on presented arguements and accepted flags
	ALLFLGS="$1"
	while [[ "$ALLFLGS" == *'::'* ]]; do
		ALLFLGS="${ALLFLGS/::/:}"
	done
	while [[ "$ALLFLGS" == *',,'* ]]; do
		ALLFLGS="${ALLFLGS/,,/,}"
	done
	while [[ "$ALLFLGS" == *'---'* ]]; do
		ALLFLGS="${ALLFLGS/---/--}"
	done
	TMPLNGFLGS="--${ALLFLGS#*--}"
	SHRTFLGS="${ALLFLGS%%--*}"
	SHRTFLGS="${SHRTFLGS//-/}"
	TMPSHRTFLGS="$SHRTFLGS"
	if [ "${SHRTFLGS::1}" = ':' ]; then
		SHRTFLGS="${SHRTFLGS:1}"
		ERRHNDL=true
	else
		ERRHNDL=false
	fi
	CURFLG=0
	REQARGS=''
	NOREQARGS=''
	for CURARG in "${@:3}"; do
		if [ "$CURARG" = '-' ] || [ "$CURARG" = '--' ]; then
			if $ERRHNDL; then
				local FLG[$CURFLG] ARG[$CURFLG]
				FLG[$CURFLG]='?'
				ARG[$CURFLG]="$CURARG"
				CURFLG=$((CURFLG + 1))
				continue 1
			else
				printf -- "$CURARG is invalid!\n" >&2
				return 1
			fi
		fi
		if [[ "$CURARG" == '-'* ]]; then
				if [ -n "$REQARGS" ]; then
					if $ERRHNDL; then
						while [ -n "$REQARGS" ]; do
							TMP1="${REQARGS%%,*}"
							local ARG[$TMP1]
							ARG[$TMP1]="${FLG[$TMP1]}"
							FLG[$TMP1]='?'
							REQARGS="${REQARGS#$TMP1,}"
						done
					else
						TMP1="${REQARGS%%,*}"
						printf -- "${FLG[$TMP1]} no supplied arguement!\n" >&2
						return 1
					fi
				fi
			if [[ "$CURARG" == '--'* ]]; then
				if [[ "$ALLFLGS" != *"$CURARG"* ]]; then
					if $ERRHNDL; then
						local FLG[$CURFLG] ARG[$CURFLG]
						FLG[$CURFLG]="?"
						ARG[$CURFLG]="$CURARG"
						CURFLG=$((CURFLG + 1))
						continue 1
					else
						printf -- "$CURARG is invalid flag!\n" >&2
						return 1
					fi
				fi
				if [[ "$TMPLNGFLGS" = *"$CURARG"* ]]; then
					TMP2="$TMPLNGFLGS"
					while [ -n "$TMP2" ]; do
						if [[ "$TMP2" = "$CURARG"* ]]; then
							local FLG[$CURFLG]
							FLG[$CURFLG]="$CURARG"
							TMP2="${TMP2#$CURARG}"
							if [ "${TMP2::1}" = ':' ]; then
								[ "${TMP2:1:1}" != ',' ] && TMPLNGFLGS="${TMPLNGFLGS/$CURARG:}"
								REQARGS="$REQARGS$CURFLG,"
							elif [ "${TMP2::1}" = ',' ]; then
								if [ "${TMP2:1:1}" = ':' ]; then
									REQARGS="$REQARGS$CURFLG,"
								else
									NOREQARGS="$NOREQARGS$CURFLG,"
								fi
							else
								TMPLNGFLGS="${TMPLNGFLGS/$CURARG:}"
								NOREQARGS="$NOREQARGS$CURFLG,"
							fi
							CURFLG=$((CURFLG + 1))
							break 1
						else
							TMP2="${TMP2:2}"
							TMP2="--${TMP2#*--}"
						fi
					done
				elif $ERRHNDL; then
					local FLG[$CURFLG] ARG[$CURFLG]
					FLG[$CURFLG]="?"
					ARG[$CURFLG]="$CURARG"
					CURFLG=$((CURFLG + 1))
					continue 1
				else
					printf -- "$CURARG cannot be used again!\n" >&2
					return 1
				fi
			else
				CURARG="${CURARG:1}"
				while [ -n "$CURARG" ]; do
					TMP1="${CURARG::1}"
					CURARG="${CURARG:1}"
					if [[ "$SHRTFLGS" != *"$TMP1"* ]]; then
						if $ERRHNDL; then
							local FLG[$CURFLG] ARG[$CURFLG]
							FLG[$CURFLG]="?"
							ARG[$CURFLG]="-$TMP1"
							CURFLG=$((CURFLG + 1))
							continue 1
						else
							printf -- "-$TMP1 is invalid flag!\n" >&2
							return 1
						fi
					fi
					if [[ "$TMPSHRTFLGS" = *"$TMP1"* ]]; then
						TMP2="$TMPSHRTFLGS"
						while [ -n "$TMP2" ]; do
							if [[ "$TMP2" = "$TMP1"* ]]; then
								local FLG[$CURFLG]
								FLG[$CURFLG]="$TMP1"
								TMP2="${TMP2:1}"
								TMP1="${TMP2::1}"
								if [ "$TMP1" = ':' ]; then
									[ "${TMP2:1:1}" != ',' ] && TMPSHRTFLGS="${TMPSHRTFLGS/${FLG[$CURFLG]}:}"
									REQARGS="$REQARGS$CURFLG,"
								elif [ "$TMP1" = ',' ]; then
									if [ "${TMP2:1:1}" = ':' ]; then
										REQARGS="$REQARGS$CURFLG,"
									else
										NOREQARGS="$NOREQARGS$CURFLG,"
									fi
								else
									TMPSHRTFLGS="${TMPSHRTFLGS/${FLG[$CURFLG]}}"
									NOREQARGS="$NOREQARGS$CURFLG,"
								fi
								FLG[$CURFLG]="-${FLG[$CURFLG]}"
								CURFLG=$((CURFLG + 1))
								break 1
							else
								TMP2="${TMP2:1}"
							fi
						done
					elif $ERRHNDL; then
						local FLG[$CURFLG] ARG[$CURFLG]
						FLG[$CURFLG]="?"
						ARG[$CURFLG]="-$TMP1"
						NOREQARGS="$NOREQARGS$CURFLG,"
						CURFLG=$((CURFLG + 1))
						continue 1
					else
						printf -- "-$TMP1 cannot be used again!\n" >&2
						return 1
					fi
				done
			fi
		elif [ -n "$REQARGS" ]; then
			TMP1="${REQARGS%%,*}"
			local ARG[$TMP1]
			ARG[$TMP1]="$CURARG"
			REQARGS="${REQARGS#$TMP1,}"
			NOREQARGS="$NOREQARGS$TMP1,"
		elif [ -z "${FLG[0]}" ]; then
			if $ERRHNDL; then
				local FLG[$CURFLG] ARG[$CURFLG]
				FLG[$CURFLG]="?"
				ARG[$CURFLG]="$CURARG"
				CURFLG=$((CURFLG + 1))
			else
				printf -- "$CURARG is not a flag!\n" >&2
				return 1
			fi
		elif [ -z "$REQARGS" ]; then
			if $ERRHNDL; then
				local FLG[$CURFLG] ARG[$CURFLG]
				FLG[$CURFLG]='?'
				if [[ "$NOREQARGS" = *"$((CURFLG - 1))"* ]]; then
					ARG[$CURFLG]="$CURARG"
					NOREQARGS="$NOREQARGS$CURFLG,"
				elif [ "${FLG[$((CURFLG - 1))]}" = '?' ]; then
					ARG[$CURFLG]="${ARG[$((CURFLG - 1))]}"
				else
					ARG[$CURFLG]="${FLG[$((CURFLG - 1))]}"
				fi
				CURFLG=$((CURFLG + 1))
			else
				printf -- "${FLG[$((CURFLG - 1))]} over supplied arrguements!\n" >&2
				return 1
			fi
		fi
	done
	if [ -n "$REQARGS" ]; then
		if $ERRHNDL; then
			while [ -n "$REQARGS" ]; do
				TMP1="${REQARGS%%,*}"
				local ARG[$TMP1]
				ARG[$TMP1]="${FLG[$TMP1]}"
				FLG[$TMP1]='?'
				REQARGS="${REQARGS#$TMP1,}"
			done
		else
			TMP1="${REQARGS%%,*}"
			printf -- "${FLG[$TMP1]} no supplied arguement!\n" >&2
			return 1
		fi
	fi
	#first output to function call location
	if [ -n "${FLG[0]}" ]; then
		for REQARGS in "${!FLG[@]}"; do
			if [ $REQARGS -eq 0 ]; then
				eval export "$2"="${FLG[0]}"
			else
				FLG[$((REQARGS - 1))]="${FLG[$REQARGS]}"
			fi
			unset FLG[$REQARGS]
		done
		if [ ${#ARG[@]} -ne 0 ]; then
			[ -z "${ARG[0]}" ] && unset OPTARG
			for REQARGS in "${!ARG[@]}"; do
				if [ $REQARGS -eq 0 ]; then
					[ -n "${ARG[0]}" ] && export OPTARG="${ARG[0]}"
				else
					ARG[$((REQARGS - 1))]="${ARG[$REQARGS]}"
				fi
				unset ARG[$REQARGS]
			done
		fi
		REQARGS='$(declare -p FLG)'
		eval export $FLGVARNAME="$REQARGS"
		REQARGS='$(declare -p ARG)'
		eval export $ARGVARNAME="$REQARGS"
		return 0
	else
		return 1
	fi
}
while GETARGS :L,i:l,p:Pg:GD:E:--endpoint:--port:--iface:--network:--ip-beg:--ip-end:--lan:--isolate--isolate--route-add:,--route-rem:,--gateway:--dns-on--dns-off--dns: x "$@"; do
	OPTARG="${OPTARG// /}"
	case $x in
		-L)
			WGSUPDATE=true
			echo 'make live, otherwise new config file is generated in place of old after move of old to .old';;
		-i)
			IFACE="$OPTARG"
			echo 'use this wireguard interface name';;
		-p)
			WGC="$OPTARG"
			echo 'show peer "client" info';;
		-P)
			SHOWALLWGC=true
			echo 'show all peer "client" info';;
		-g)
			WRITEWGC=true
			WRITEWGS=true
			WGC="$OPTARG"
			echo 'generate peer "client" info';;
		-G)
			WRITEALLWGC=true
			WRITEWGS=true
			echo 'generate all peers "client" info';;
		-d)
			WRITEWGS=true
			WGC="$OPTARG"
			echo 'disable client';;
		-D)
			CHECKALLWGC=true
			WRITEWGS=true
			DISABLE=true
			echo 'disable all clients';;
		-e)
			WRITEWGS=true
			WGCSTATUS=''
			WGC="$OPTARG"
			echo 'enable client';;
		-E)
			CHECKALLWGC=true
			WRITEWGS=true
			ENABLE=true
			echo 'enable all clients';;
		--endpoint)
			WRITEALLWGC=true
			WRITEWGS=true
			ENDPOINT="$OPTARG"
			echo 'endpoint';;
		--port)
			#check if valid port
			WRITEALLWGC=true
			WRITEWGS=true
			PORT="$OPTARG"
			echo 'endpoint port';;
		--iface)
			#check if new interface name available
			WRITEWGS=true
			NEWIFACE="$OPTARG"
			echo 'change interface name';;
		--network)
			#check if new network available
			WRITEALLWGC=true
			WRITEWGS=true
			NTWRK="$OPTARG"
			echo 'set wireguard interface network';;
		--ip-beg)
			CHECKALLWGC=true
			WRITEWGS=true
			if isip "$OPTARG"; then
				#check if OPTARG in interface network
				NTWRK_BEG="$OPTARG"
			else
				errout "$OPTARG is not a valid IP address!"
			fi
			echo 'peer range start';;
		--ip-end)
			CHECKALLWGC=true
			WRITEWGS=true
			if isip "$OPTARG"; then
				#check if OPTARG in interface network
				NTWRK_END="$OPTARG"
			else
				errout "$OPTARG is not a valid IP address!"
			fi
			echo 'peer range finish';;
		--lan)
			#check if interface exists
			WRITEALLWGC=true
			WRITEWGS=true
			LAN="$OPTARG"
			echo 'connected lan';;
		--isolate)
			WRITEALLWGC=true
			WRITEWGS=true
			ISOLATE=false
			echo 'isolate lan';;
		--unisolate)
			WRITEALLWGC=true
			WRITEWGS=true
			ISOLATE=true
			echo 'unisolate lan';;
		--network-add)
			WRITEALLWGC=true
			WRITEWGS=true
			if iscidr "$OPTARG"; then
				[ -n "$ADD_ROUTES" ] && OPTARG=", $OPTARG"
				ADD_ROUTES="$ADD_ROUTES$OPTARG"
			else
				errout "$OPTARG is not a valid CIDR address!"
			fi
			echo 'add network route from server and clients';;
		--network-rem)
			WRITEALLWGC=true
			WRITEWGS=true
			if iscidr "$OPTARG"; then
				[ -n "$REM_ROUTES" ] && OPTARG=", $OPTARG"
				REM_ROUTES="$REM_ROUTES$OPTARG"
			else
				errout "$OPTARG is not a valid CIDR address!"
			fi
			echo 'remove network route from server and clients';;
		--gateway-on)
			WRITEALLWGC=true
			WRITEWGS=true
			GATEWAY=true
			echo 'force lan is gateway';;
		--gateway-off)
			WRITEALLWGC=true
			WRITEWGS=true
			GATEWAY=false
			echo 'lan is not gateway';;
		--dns-on)
			WRITEALLWGC=true
			WRITEWGS=true
			USE_DNS=true
			echo 'force peer dns server';;
		--dns-off)
			WRITEALLWGC=true
			WRITEWGS=true
			USE_DNS=false
			echo 'no peer dns server';;
		--dns)
			WRITEALLWGC=true
			WRITEWGS=true
			DNS_SRV="$OPTARG"
			echo 'peer dns server';;
		:|*|?)
			printf "Edit variables in begining of script before running!\n\
			\n\
			Usage:\n\
			$WGSCRIPTPATH <REQUIRED> <OPTION> <LIVE>\n\
			\n\
			REQUIRED:\n\
			\t\t- A hostname or username controlled by this script for this Wireguard interface name.\n\
			\t\t  Creates a peer if 'new' OPTION specified. Provides details (config file) for hostname or username.\n\
			\n\
			\t\t- If Wireguard interface name provided script will stand up or restart the interface using existing configuration.\n\
			\n\
			OPTION:\n\
			\tnew\t- Generate a new private and public key for specified hostname or username and display.\n\
			\n\
			\tremove\t- Remove peer with specified hostname or username.\n\
			\n\
			LIVE:\n\
			\tlive\t- If provided will update the Wireguard interface with new or removed peer information.\n\
			\t\t  Configuration files are otherwise generated for next interface start.\n" 2>&1
			exit 1;;
	esac
done

#DETERMINE WIREGAURD INTERFACE NAME FROM SCRIPT NAME (wireguard_X), SCRIPT PATH, OR CREATES NEW DEFAULT WIREGAURD INTERFACE (wgX) WITH CONFIGURATION FILES
#VERIFY SCRIPT NAME
WGSCRIPTNAME="${0##*/}"
WGSCRIPTPATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
WGSCRIPTWRITE() {
	local x WGSCRIPTPATH_NEW WGSCRIPT_NEW
	WGSCRIPTPATH_NEW="/etc/wireguard/generatewg_$1"
	if [ ! -f "$WGSCRIPTPATH_NEW" ]; then
		WGSCRIPT_NEW=($(<$WGSCRIPTPATH$WGSCRIPTNAME))
		for x in "${!WGSCRIPT_NEW[@]}"; do
			[[ "${}" = "IFACE=''"* ]] && WGSCRIPT_NEW[$x]="IFACE='$1'" && break 1
		done
		printf -- "${WGSCRIPT_NEW[@]}" > "$WGSCRIPTPATH_NEW"
		chown root "$WGSCRIPTPATH_NEW"
		chmod 700 "$WGSCRIPTPATH_NEW"
		err "Script copied for use with $1!"
	fi
	err "Use $WGSCRIPTPATH_NEW instead! Script file can be moved."
}
if [ -z $IFACE ]; then
	if [ ! "$WGSCRIPTNAME" = 'generatewg_' ] && [[ "$WGSCRIPTNAME" == 'generatewg_'* ]]; then
		IFACE="${WGSCRIPTNAME#*_}"
	else
		for x in {0..255}; do
			if [ ! -d /sys/class/net/wg${x} ] && [ ! -f /etc/wireguard/wg${x}.conf ]; then
				WRITEWGS=true
				IFACE="wg$x"
				err "Script IFACE interface variable not set!\nScript name has no hint!\nIFACE set to $IFACE!"
				WGSCRIPTWRITE "$IFACE"
				break 1
			fi
		done
	fi
elif [ ! "$WGSCRIPTNAME" = "generatewg_$IFACE" ]; then
	err "Script name is improper!"
	WGSCRIPTWRITE "$IFACE"
fi

#PARSE CONFIG FILE
WGSFULLPATH="/etc/wireguard/$IFACE.conf"
if [ -f "$WGSFULLPATH" ]; then
	WGCONFIG=($(<$WGSFULLPATH))
	for x in "${!WGCONFIG[@]}"; do
		if [ -z "$y" ]; then
			case "${WGCONFIG[$x]}" in
PrivateKey = *) PRIVKEY="${WGCONFIG[$x]#* = }";;
ListenPort = *) CUR_PORT="${WGCONFIG[$x]#* = }";;
\#PresharedKey) CUR_USEPREKEY=true;;
\#LAN = *) CUR_LAN="${WGCONFIG[$x]#* = }";;
\#GATEWAY) CUR_GATEWAY=true;;
				\#ISOLATE) CUR_ISOLATE=true;;
				\#routes = *) CUR_ROUTES="${WGCONFIG[$x]#* = }";;
				\#NTWRK_BEG = *) CUR_NTWRK_BEG="${WGCONFIG[$x]#* = }";;
				\#NTWRK_END = *) CUR_NTWRK_END="${WGCONFIG[$x]#* = }";;
				\#Endpoint = *) CUR_ENDPOINT="${WGCONFIG[$x]#* = }";;
				\#PersistentKeepalive = *) CUR_KEEPALIVE="${WGCONFIG[$x]#* = }";;
Address = *) CUR_NTWRK="${WGCONFIG[$x]#* = }";;
				\#DNS = *) CUR_DNS_SRV="${WGCONFIG[$x]}";;
				\#use_dns) CUR_USE_DNS=true;;
				\#MTU = *) CUR_NTWRK_MTU="${WGCONFIG[$x]#* = }";;
				\#PreUp = *) CUR_PREUP="${WGCONFIG[$x]#* = }";;
				\#PostUp = *) CUR_POSTUP="${WGCONFIG[$x]#* = }";;
				\#PreDown = *) CUR_PREDOWN="${WGCONFIG[$x]#* = }";;
				\#PostDown = *) CUR_POSTDOWN="${WGCONFIG[$x]#* = }";;
\[Peer]*) break 1;;
			esac
			unset WGCONFIG[$x]
		else
			! SHOWALLWGC && ! CHECKALLWGC && ! WRITEALLWGC && [ 1 -eq $y ] && break 1
			if [ -z "${PEERS[$y]}" ] ||; then
			case "${WGCONFIG[$x]}" in
				*\[Peer]*) [ -n "${PEERS[$y]}" ] && y=$((y + 1)) && [ '#' = "${WGCONFIG[$x]::1}" ] && PEERSSTATUSES[$y]='#' || PEERSSTATUSES[$y]='';;
				\#peer = *) z="${WGCONFIG[$x]#\#peer = }" && SHOWALLWGC || CHECKALLWGC || WRITEALLWGC || [[ "$WGC" = *",$z,"* ]] && PEERS[$y]="$z";;
				*PublicKey = *) [ -n "${PEERS[$y]}" ] && PEERSPUBKEYS[$y]="${WGCONFIG[$x]#* = }" && [ -z "${PEERSPUBKEYS[$y]}" ] && peererr "$y";;
				\#prekey = *) [ -n "${PEERS[$y]}" ] && PEERSPREKEYS[$y]="${WGCONFIG[$x]#* = }";;
				*PresharedKey = *) [ -n "${PEERS[$y]}" ] && PEERSPREKEYS[$y]="${WGCONFIG[$x]#* = }";;
				*AllowedIPs = *) [ -n "${PEERS[$y]}" ] && PEERSIPS[$y]="${WGCONFIG[$x]#* = }";;
				*PersistentKeepalive = *) [ -n "${PEERS[$y]}" ] && PEERSALIVES[$y]="${WGCONFIG[$x]#* = }";;
				\#DNS = *) [ -n "${PEERS[$y]}" ] && PEERSDNSS[$y]="${WGCONFIG[$x]#* = }";;
				\#MTU = *) [ -n "${PEERS[$y]}" ] && PEERSMTUS[$y]="${WGCONFIG[$x]#* = }";;
			esac
		fi
	do
else
	WRITEWGS=true
fi

#INPUT SANTIZATION
torf() {
	[ $1 = true ] || [ $1 = false ] && return 0
	return 1
}
x='^[0-9]+$'
[ -n "$CUR_PORT" ]  && ! [[ $CUR_PORT =~ $x ]] || [ $CUR_PORT -lt 1 ] || [ $CUR_PORT -gt 65535 ] && errout "Invalid endpoint port from configuration file ($CUR_PORT)!"
if [ -n "$PORT" ]; then
		! [[ $PORT =~ $x ]] || [ $PORT -lt 1 ] || [ $PORT -gt 65535 ] && errout "Invalid endpoint port from script or user ($PORT)!"
		if [ -n "$CUR_PORT" ] && [ $CUR_PORT -ne $PORT ]; then
			err "Changing endpoint port from $CUR_PORT to $PORT!"
			PORT=$CUR_PORT
			unset CUR_PORT
			WRITEWGS=true
			CHECKALLWGC=true
		fi
elif [ -n "$CUR_PORT" ]; then
	PORT=$CUR_PORT
	unset CUR_PORT
fi
[ -n "$CUR_NTWRK" ] && ! iscidr "$CUR_NTWRK" && errout "Invalid endpoint interface network from configuration file ($CUR_NTWRK)!"
if [ -n "$NTWRK" ]; then
		! iscidr "$NTWRK" && errout "Invalid endpoint interface network from script or user ($NTWRK)!"
		if [ -n "$CUR_NTWRK" ] && [ "$CUR_NTWRK" != "$NTWRK" ]; then
			err "Changing endpoint interface network from $CUR_NTWRK to $NTWRK!"
			NTWRK="$CUR_NTWRK"
			unset CUR_NTWRK
			WRITEWGS=true
			CHECKALLWGC=true
		fi
elif [ -n "$CUR_NTWRK" ]; then
	NTWRK="$CUR_NTWRK"
	unset CUR_NTWRK
fi
[ -z "$CUR_USEPREKEY" ] && CUR_USEPREKEY=false
if [ -n "$USEPREKEY" ]; then
	! torf "$USEPREKEY" && errout "USEPREKEY variable not true or false from script!"
	if [ $CUR_USEPREKEY != $USEPREKEY ]; then
		err "All clients will have configuration files generated!\nAll clients must update to this new configuration once live!"
		USEPREKEY=$CUR_USEPREKEY
		unset CUR_USEPREKEY
		WRITEWGS=true
		WRITEALLWGC=true
	fi
else
	USEPREKEY=$CUR_USEPREKEY
	unset CUR_USEPREKEY
fi
[ -n "$CUR_LAN" ] && [ ! -d "/sys/class/net/$CUR_LAN" ] && errout "Invalid endpoint LAN interface from configuration file ($CUR_LAN)!"
if [ -n "$LAN" ]; then
		[ ! -d "/sys/class/net/$LAN" ] && errout "Invalid endpoint LAN interface from script or user ($LAN)!"
		if [ -n "$CUR_LAN" ] && [ "$CUR_LAN" != "$LAN" ]; then
			err "Changing endpoint interface network from $CUR_LAN to $LAN!"
			NTWRK="$CUR_NTWRK"
			unset CUR_NTWRK
			WRITEWGS=true
			CHECKALLWGC=true
		fi
elif [ -n "$CUR_LAN" ]; then
	LAN="$CUR_LAN"
	unset CUR_LAN
fi
[ -z "$CUR_GATEWAY" ] && CUR_GATEWAY=false
if [ -n "$GATEWAY" ]; then
	! torf "$GATEWAY" && errout "USEPREKEY variable not true or false from script!"
	if [ $CUR_GATEWAY != $GATEWAY ]; then
		err "All clients will have configuration files generated!\nAll clients must update to this new configuration once live!"
		GATEWAY=$CUR_GATEWAY
		unset CUR_GATEWAY
		WRITEWGS=true
		WRITEALLWGC=true
	fi
else
	USEPREKEY=$CUR_GATEWAY
	unset CUR_GATEWAY
fi

[ -n "$NTWRK_BEG" ] && ! isip "$NTWRK_BEG" && errout "Invalid peer range begin IP!"
[ -n "$NTWRK_END" ] && ! isip "$NTWRK_END" && errout "Invalid peer range end IP!"
[ -n "$ROUTES" ] && ! ismulticidr "$ROUTES" && errout "Invalid route list!"
[ -n "$ADD_ROUTES" ] && ! ismulticidr "$ADD_ROUTES" && errout "Invalid route to add!"
[ -n "$REM_ROUTES" ] && ! ismulticidr "$REM_ROUTES" && errout "Invalid route to remove!"
[ -n "$MTU" ] && [ $MTU -eq 0 ] && unset MTU
if [ -n "$DNS_SRV" ]; then
	! isip "$DNS_SRV" && errout "Invalid DNS IP!"
	! dig +time=2 +tries=2 +retry=0 +short @$DNS_SRV A dns.google.com &> /dev/null && errout "$DNS_SRV is not a valid DNS!"
fi

#LOAD WIREGAURD INTERFACE CONFIGURATION FILE TO MEMORY AND SET VARIABLES OR CREATE FILE
#VERIFY CONFIGURATION FILE CONTINUITY AGAINST SCRIPT SETTINGS, IF DIFFERENT AND CHANGES ACCEPTED BY USER MODIFIES CONFIGURATION FILE TO MATCH SCRIPT
WGCDIR="$WGSDIR$1/"

[ "$IFACE" =  "$(defaultinterface)" ]; then
	echo 1>/proc/sys/net/ipv4/ip_forward
	iptables -A INPUT -i LAN-LAN -s 10.9.0.0/24 -j ACCEPT
	iptables -A INPUT -i VPN2 -s 10.10.0.0/24 -j ACCEPT
	iptables -A OUTPUT -o LAN-LAN -s 10.10.0.0/24 -d 10.9.0.0/24 -j ACCEPT
	iptables -A OUTPUT -o VPN2 -s 10.9.0.0/24 -d 10.10.0.0/24 -j ACCEPT
	iptables -A FORWARD -i LAN-LAN -o VPN2 -j ACCEPT
	iptables -A FORWARD -i VPN2 -o LAN-LAN -j ACCEPT
fi

#VERIFY WIREGAURD INTERFACE IP, OR CREATE NEW WIREGUARD NETWORK FROM DEFAULT "LAN" INTERFACE AS TEMPLATE
cidrtomask() {
	if [ -z $1 ] || [[ ! $1 =~ ^[0-9]+$ ]] || [ $1 -lt 0 ] || [ $1 -gt 32 ]; then
		printf "CIDR bit length not provided to cidrtomask function!\n" 1>&2
		exit 1
	fi
	local i mask full_octets partial_octet
	full_octets=$(($1/8))
	partial_octet=$(($1%8))
	for ((i=0;i<4;i+=1)); do
		if [ $i -lt $full_octets ]; then
			mask+=255
		elif [ $i -eq $full_octets ]; then
			mask+=$((256 - 2**(8-$partial_octet)))
		else
			mask+=0
		fi
		test $i -lt 3 && mask+=.
	done
	printf "$mask"
}
networkmin() {
	if [ -z $1 ] || [[ ! $1 =~ ^[0-9/.]+$ ]] || [[ $1 != *"/"* ]]; then
		printf "CIDR network not provided to networkmin function!\n" 1>&2
		exit 1
	fi
	local a1 a2 a3 a4 m1 m2 m3 m4
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask ${1#*/})"
	a1=$((a1 & m1))
	a2=$((a2 & m2))
	a3=$((a3 & m3))
	a4=$((a4 & m4))
	printf "$a1.$a2.$a3.$a4"
}
networkmax() {
	if [ -z $1 ] || [[ ! $1 =~ ^[0-9/.]+$ ]] || [[ $1 != *"/"* ]]; then
		printf "CIDR network not provided to networkmax function!\n" 1>&2
		exit 1
	fi
	local a1 a2 a3 a4 m1 m2 m3 m4
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask ${1#*/})"
	a1=$(( ( 255 ^ m1 ) | a1 ))
	a2=$(( ( 255 ^ m2 ) | a2 ))
	a3=$(( ( 255 ^ m3 ) | a3 ))
	a4=$(( ( 255 ^ m4 ) | a4 ))
	printf "$a1.$a2.$a3.$a4"
}
getnextnetwork() {
	if [ -z $1 ] || [[ ! $1 =~ ^[0-9/.]+$ ]] || [[ $1 != *"/"* ]]; then
		printf "CIDR network not provided to getnextnetwork function!\n" 1>&2
		exit 1
	fi
	local a1 a2 a3 a4 a5 a6 h1 h2 h3 h4 m1 m2 m3 m4 address
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	h1=$a1
	h2=$a2
	h3=$a3
	h4=$a4
	a5=${1#*/}
	a6=$(( 32 - a5 ))
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask $a5)"
	address=$((((((((((a1 << 8) | a2) << 8) | a3) << 8) | a4) >> a6) + 1) << a6 ))
	a4=$(( ((255 & address) & m4) | (h4 & (255 ^ m4)) ))
	address=$((address >> 8))
	a3=$(( ((255 & address) & m3) | (h3 & (255 ^ m3)) ))
	address=$((address >> 8))
	a2=$(( ((255 & address) & m2) | (h2 & (255 ^ m2)) ))
	address=$((address >> 8))
	a1=$(( ((255 & address) & m1) | (h1 & (255 ^ m1)) ))
	[ $h1 -eq 10 ] && [ $a1 -ne 10 ] && a1=10
	[ "$h1$h2" = "192168" ] && [ "$a1$a2" != "192168" ] && a1=192 && a2=168
	[ "$h1$h2" = "169254" ] && [ "$a1$a2" != "169254" ] && a1=169 && a2=254
	[ $a1 -eq 172 ] && [ $a2 -gt 31 ] && a2=16
	printf "$a1.$a2.$a3.$a4/$a5"
}
getnexthost() {
	if [ -z $1 ] || [[ ! $1 =~ ^[0-9/.]+$ ]] || [[ $1 != *"/"* ]]; then
		printf "CIDR network not provided to getnexthost function!\n" 1>&2
		exit 1
	fi
	local a1 a2 a3 a4 a5 h1 h2 h3 h4 m1 m2 m3 m4 address
	IFS=. read -r a1 a2 a3 a4<<<"${1%/*}"
	h1=$a1
	h2=$a2
	h3=$a3
	h4=$a4
	a5=${1#*/}
	IFS=. read -r m1 m2 m3 m4<<<"$(cidrtomask $a5)"
	address=$((((((((a1 << 8) | a2) << 8) | a3) << 8) | a4) + 1))
	a4=$((255 & address))
	a4=$(((a4 & m4) | (a4 & (255 ^ m4))))
	address=$((address >> 8))
	a3=$((255 & address))
	a3=$(((a3 & m3) | (a3 & (255 ^ m3))))
	address=$((address >> 8))
	a2=$((255 & address))
	a2=$(((a2 & m2) | (a2 & (255 ^ m2))))
	address=$((address >> 8))
	a1=$((255 & address))
	a1=$(((a1 & m1) | (a1 & (255 ^ m1))))
	printf "$a1.$a2.$a3.$a4/$a5"
}
rangeunused() {
	if [ -z $1 ] || ! [[ $1 =~ ^[0-9/.]+$ ]] || [[ $1 != *"/"* ]]; then
		printf "CIDR network not provided to rangeunused function!\n" 1>&2
		exit 1
	fi
	local a1 a2 a3 a4 a5 cur max address
	a5=${1#*/}
	IFS=. read -r a1 a2 a3 a4<<<"$(networkmax $1)"
	max=$(( ( a1 << 24 ) + ( a2 << 16 ) + ( a3 << 8 ) + a4 ))
	address=$(networkmin $1)
	IFS=. read -r a1 a2 a3 a4<<<"$address"
	while [[ "$(ip route get $a1.$a2.$a3.$a4/$a5)" == *"via"* ]] || return 1; do
		cur=$(( ( a1 << 24 ) + ( a2 << 16 ) + ( a3 << 8 ) + a4 ))
		[ $cur -eq $max ] && break
		a4=$(( a4 + 1 ))
		[ $a4 -eq 256 ] && a4=0 && a3=$(( a3 + 1 ))
		[ $a3 -eq 256 ] && a3=0 && a2=$(( a2 + 1 ))
		[ $a2 -eq 256 ] && a2=0 && a1=$(( a1 + 1 ))
		[ $a1 -eq 256 ] && a1=0
	done
	#IFS=. read -r a1 a2 a3 a4<<<"$address"
	#nmap or icmp check?
	return
}
getnetworkof() {
	if [ -z $1 ] || ! ip address show "$1"|grep -q 'inet '; then
		printf 'getnetworkof function provided no or invalid network name!\n' 1>&2
		return 1
	fi
	local address
	address=$(ip address show "$1"|grep 'inet ')
	address=${address#*inet }
	printf "${address%% *}"
}
generatenetworkfrom() {
	local address nextaddress
	if [ -n "$1" ]; then
		printf "Using $1 to generate a network!\n" 1>&2
		address=$(getnetworkof "$1")
	fi
	if [ -z $address ]; then
		address=$(ip route show default)
		address=${address#* dev }
		address=${address%% *}
		printf "Using default ($address) to generate a network!\n" 1>&2
		address=$(getnetworkof "$address")
	fi
	nextaddress=$(getnextnetwork "$address")
	while ! rangeunused "$nextaddress"; do
		nextaddress=$(getnextnetwork "$nextaddress")
		if [ "$address" = "$nextaddress" ]; then
			printf "generatenetworkfrom function could not determine an unused network!\n" 1>&2
			exit 1
		fi
	done
	printf "$nextaddress"
}
clientconfignetwork() {
	#WARNING!!!! This function has the potential to "guess" prior existing networks based on peer configurations wrong!
	local a1 a2 a3 a4 a5 a6 check lowest highest address generated
	if [ -n "$WGS" ]; then
		while IFS= read -r x || [ -n "$x" ]; do
			if [[ "$x" == "AllowedIPs = "* ]]; then
				address=${x//[!0-9\,\/\.]}
				address=${address%%,*}
				address=${address%/*}
				IFS=. read -r a1 a2 a3 a4<<<"$address"
			check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
				if [ -z $lowest ]; then
					lowest=$check
					highest=$check
				elif [ $check -lt $lowest ]; then
					lowest=$check
				elif [ $check -gt $highest ]; then
					highest=$check
				fi
			fi
		done <<< "$WGS"
		if [ -z $lowest ]; then
			printf 'clientconfignetwork function could not determine any peer configurations!\n' 1>&2
			return 1
		fi
	else
		printf 'No Wiregaurd server configuration for clientconfignetwork function!\n' 1>&2
		return 1
	fi
	printf 'clientconfignetwork function attempting to match an existing network to Wireguard configuration file peers!\n' 1>&2
	a6=$(generatenetworkfrom $1)
	generated=$(getnexthost $a6)
	IFS=. read -r a1 a2 a3 a4<<<"${generated%/*}"
	check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
	if [ $check -eq $lowest ] || [ $check -eq $((lowest - 1)) ]; then
		printf 'clientconfignetwork function matched a network for Wireguard configuration file peers! Verify network in configuration file!\n' 1>&2
		printf "$a6"
	else
		printf 'clientconfignetwork function attempting to guess network for Wireguard configuration file peers!\n' 1>&2
		for x in {30..8}; do
			IFS=. read -r a1 a2 a3 a4<<<"$(networkmin $address/$x)"
			a5="$a1.$a2.$a3.$((a4 + 1))"
			check=$((((a1 << 24) + (a2 << 16) + (a3 << 8) + a4) + 2))
			if [ $check -eq $lowest ]; then
				IFS=. read -r a1 a2 a3 a4<<<"$(networkmax $address/$x)"
				check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
				[ $check -gt $highest ] && address="$a5/$x" && a5=$x && break
			else
				IFS=. read -r a1 a2 a3 a4<<<"$(networkmax $address/$x)"
				generated="$a1.$a2.$a3.$((a4 - 1))"
				check=$((((a1 << 24) + (a2 << 16) + (a3 << 8) + a4) - 2))
				if [ $check -eq $highest ]; then
					IFS=. read -r a1 a2 a3 a4<<<"$a5"
					check=$(((a1 << 24) + (a2 << 16) + (a3 << 8) + a4))
					[ $check -le $lowest ] && address="$generated/$x" && a5=$x && break
				fi
			fi
			a5=''
		done
		if [ -z $a5 ]; then
			printf 'clientconfignetwork function could not determine a network from Wireguard confifuration file!\n' 1>&2
			return 1
		else
			if [ ${a6#*/} -lt $((a5 + 5)) ] && [ ${a6#*/} -gt $((a5 - 5)) ]; then
				printf 'clientconfignetwork function guessed a network close to existing network! Using existing network! Verify network in configuration file!\n' 1>&2
				printf "$a6"
			else
				printf 'clientconfignetwork function guessed a network! Verify network in configuration file!\n' 1>&2
				printf "$address"
			fi
		fi
	fi
}
if [ -z $NTWRK ]; then
	printf "Script variable NTWRK not set! Attempting to determine Wireguard network from corrupted config file!\n" 1>&2
	WRITEWGS=true
	NTWRK=$(clientconfignetwork "$LAN")
	WGC=$NTWRK
	if [ -n "$NTWRK" ]; then
		while ! rangeunused "$NTWRK"; do
			NTWRK=$(getnextnetwork $NTWRK)
			[ "$WGC" = "$NTWRK" ] && NTWRK='' && break
		done
	fi
	if [ -z $NTWRK ]; then
		printf "Generating network for Wireguard interface!" 1>&2
		NTWRK=$(generatenetworkfrom "$LAN")
	fi
fi

#VERIFY WIREGUARD PEER RANGE BEGINING
if [ -n "$NTWRK_BEG" ] && [ ! "$(networkmin $NTWRK)" = "$(networkmin $NTWRK_BEG)" ]; then
	printf "Peer address range begin not in contigous network with Wiregaurd interface! Correct script variables!" 1>&2
	exit 1
fi

#VERIFY WIREGUARD PEER RANGE ENDING
if [ -n "$NTWRK_END" ] && [ ! "$(networkmin $NTWRK)" = "$(networkmin $NTWRK_END)" ]; then
	printf "Peer address range end not in contigous network with Wiregaurd interface! Correct script variables!" 1>&2
	exit 1
fi

#VERIFY ENDPOINT KEYS
if [ -z $WGS_PRIKEY ]; then
	WRITEWGS=true
	printf "No Wireguard interface private key! Generating new key!" 1>&2
	WGS_PRIKEY=$(wg genkey)
fi
WGS_PUBKEY=$(wg pubkey<<<"$WGS_PRIKEY")

#VERIFY ENDPOINT PORT
if [ -z $PORT ]; then
	WRITEWGS=true
	PORT="51820"
	while wg show|grep 'listening port:'|grep -q "$PORT"; do
		PORT=$((PORT + 1))
	done
fi

#VERIFY WIREGUARD ENDPOINT FOR PEERS
if [ -z $ENDPOINT ]; then
	WRITEWGS=true
	printf "Script variable ENDPOINT not set! Attempting to find public WAN IP!\n" 1>&2
	ENDPOINT="$(dig +short myip.opendns.com @resolver1.opendns.com)"
	[ -z $ENDPOINT ]; then
		printf "Could not determine public WAN IP! Edit script variables and rerun!\n" 1>&2
		exit 1
	fi
	printf "Using $ENDPOINT as endpoint for peers! Make sure your IP won't change, or be prepared to update all clients when it does!\n" 1>&2
fi

if [ "${WGC}" = "${IFACE}" ]
	then
		if [ -d /sys/class/net/${IFACE} ]
			then
				ip link delete dev ${IFACE}
			fi
		ip link add dev ${IFACE} type wireguard && wg setconf ${IFACE} ${WGSPATH} && exit
		exit 1
	fi
if [ "${2}" = "remove" ]
	then
		if [ -d ${WGCDIR} ]
			then
				printf "${WGC} removed!\n"
				rm -rf ${WGCDIR}
			else
				printf "No Hostname or Username called ${WGC} exists!\n"
			fi
		rm -f ${WGSPATH}
		WGSPATHCREATE
		WGSLIVE ${2} ${3}
	else
		if [ ! -d ${WGCDIR} ]
			then
				mkdir -p ${WGCDIR}
			fi
		if [ -f ${WGCDIR}address ]
			then
				ADDRESS=$(<"${WGCDIR}address")
			else
				ADDRESS=$(echo $NTWRK|cut -d'.' -f1)'.'$(echo $NTWRK|cut -d'.' -f2)'.'$(echo $NTWRK|cut -d'.' -f3)'.'
				WGSFILE=$(<${WGSPATH})
				while echo "${WGSFILE}"|grep -q "${ADDRESS}${NTWRK_BEG}"
					do
						if [ $NTWRK_BEG -eq $NTWRK_END ]
							then
								printf "No available address!\n"
								exit 1
							else
								((NTWRK_BEG=NTWRK_BEG+1))
							fi
				done
				ADDRESS="${ADDRESS}${NTWRK_BEG}"
				printf "${ADDRESS}" > ${WGCDIR}address
				if [ -f ${WGC} ]
					then
						rm -f ${WGC}publickey
					fi
			fi
		if [ ! -f ${WGCDIR}privatekey ] || [ "${2}" = "new" ]
			then
				PRIVKEY=$(wg genkey)
		    		printf "${PRIVKEY}" > ${WGCDIR}privatekey
				if [ -f ${WGCDIR}publickey ]
					then
						rm -f ${WGCDIR}publickey
					fi
				if [ -f ${WGC} ]
					then
						rm -f ${WGC}publickey
					fi
			else
				PRIVKEY=$(<"${WGCDIR}privatekey")
			fi
		if [ ! -f ${WGCDIR}publickey ] || [ "${2}" = "new" ]
			then
				PUBLKEY=$(printf "${PRIVKEY}" | wg pubkey)
				printf "${PUBLKEY}" > ${WGCDIR}publickey
				if [ -f ${WGC} ]
					then
						rm -f ${WGC}publickey
					fi
			else
				PUBLKEY=$(<"${WGCDIR}publickey")
			fi
		if [ ! -f ${WGC} ] || [ "${2}" = "new" ]
			then
				WGCFILE="[Interface]\n\
PrivateKey = $PRIVKEY\n\
PublicKey = $PUBLKEY\n\
Address = $ADDRESS/$(echo $NTWRK|cut -d'/' -f2)\n\
\n\
[Peer]\n\
PublicKey = $SPUBLKEY\n\
AllowedIPs = $NTWRK\n\
Endpoint = $ENDPOINT:$PORT"
				printf "${WGCFILE}" > ${WGC}
			else
				WGCFILE=$(<"${WGC}")
			fi
		if grep -q "$ADDRESS" ${WGSPATH} && [ "${2}" = "new" ]
			then
				rm -f ${WGSPATH}
				WGSPATHCREATE
		elif ! grep -q "$ADDRESS" ${WGSPATH}
			then
				printf "\n\
\n\
[Peer]\n\
PublicKey = $PUBLKEY\n\
AllowedIPs = $ADDRESS/32" >> ${WGSPATH}
			fi
		WGSLIVE ${2} ${3}
		printf "${WGCFILE}\n"
	fi
exit



WGSPATHCREATE() {

	WGSFILE="[Interface]\n\
PrivateKey = ${SPRIVKEY}\n\
PublicKey = ${SPUBLKEY}\n\
ListenPort = ${PORT}"
	if [ -d ${WGSDIR} ]
		then
			for x in $(find ${WGSDIR} -maxdepth 1 -mindepth 1 -type d)
				do
					if [ -f ${x}/publickey ] && [ -f ${x}/address ]
						then
							WGSFILE="$WGSFILE\n\
\n\
[Peer]\n\
PublicKey = $(<${x}/publickey)\n\
AllowedIPs = $(<${x}/address)/32"
						fi
				done
		else
			mkdir -p ${WGSDIR}
		fi
	if [ ! -z $WGSCRIPTPATH_NEW ]
		then
			if [ ! -f ${WGSCRIPTPATH_NEW} ]
				then
					printf "Script moved to: ${WGSCRIPTPATH_NEW}\n"
					cp ${WGSCRIPTPATH} ${WGSCRIPTPATH_NEW}
				fi
			sed -i -e "0,/.*ENDPOINT=.*/ s/.*ENDPOINT=.*/ENDPOINT='${ENDPOINT}'/" ${WGSCRIPTPATH_NEW}
			sed -i -e "0,/.*IFACE=.*/ s/.*IFACE=.*/IFACE='${IFACE}'/" ${WGSCRIPTPATH_NEW}
		fi
	printf "${WGSFILE}" > ${WGSPATH}
}
WGSLIVE () {
	if [ "${2}" = "live" ] || ([ "${1}" = "live" ] && [ -z $3 ])
		then
			if [ -d /sys/class/net/${IFACE} ]
				then
					wg syncconf ${IFACE} ${WGSPATH}
				else
					if [ -z $WGSCRIPTPATH_NEW ]
						then
							printf "Interface ${IFACE} not running!\n\
Start interface with:\n\
${WGSCRIPTPATH} ${IFACE}\n"
						else
							printf "Interface ${IFACE} not running!\n\
Start interface with:\n\
${WGSCRIPTPATH_NEW} ${IFACE}\n"
						fi
				fi
		fi
}
